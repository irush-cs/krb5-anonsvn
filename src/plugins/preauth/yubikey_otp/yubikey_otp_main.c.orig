/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 * Copyright (C) 2006 Red Hat, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *     * Neither the name of Red Hat, Inc., nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <syslog.h> /* for krb5_klog_syslog */

#include <ykclient.h>

#include "../lib/krb5/asn.1/asn1_encode.h"

#include <krb5/preauth_plugin.h>

#include "../fast_factor.h"
#include "adm_proto.h" /* for krb5_klog_syslog */

#define KRB5_PADATA_OTP_CHALLENGE  141
#define KRB5_PADATA_OTP_REQUEST    142
#define KRB5_PADATA_OTP_CONFIRM    143
#define KRB5_PADATA_OTP_PIN_CHANGE 144

#define OTP_FLAG_RESERVED 0
#define OTP_FLAG_NEXT_OTP (1u<<1)
#define OTP_FLAG_COMBINE (1u<<2)
#define OTP_FLAG_PIN_REQUIRED (1u<<3)
#define OTP_FLAG_PIN_NOT_REQUIRED (1u<<4)
#define OTP_FLAG_MUST_ENCRYPT_NONCE (1u<<5)

struct yubikey_otp_ctx {
    char *otp;
};

struct yubikey_server_ctx {
    ykclient_t *yk_ctx;
};

static int
cli_init(krb5_context context, void **blob)
{
    struct yubikey_otp_ctx *ctx = NULL;

    ctx = calloc(1, sizeof(*ctx));
    if (ctx == NULL) {
        return ENOMEM;
    }

    *blob = ctx;

    return 0;
}

static void
cli_fini(krb5_context context, void *blob)
{
    struct yubikey_otp_ctx *ctx = blob;

    if (ctx == NULL) {
        return;
    }

    free(ctx->otp);
    free(ctx);
}

static int
preauth_flags(krb5_context context, krb5_preauthtype pa_type)
{
    return PA_REAL;
}

static krb5_error_code
get_gic_opts(krb5_context context,
                      void *plugin_context,
                      krb5_get_init_creds_opt *gic_opt,
                      const char *attr,
                      const char *value)
{
    struct yubikey_otp_ctx *otp_ctx = plugin_context;

    if (strcmp(attr, "OTP_yubikey") == 0) {
        if (otp_ctx->otp != NULL) {
            krb5_set_error_message(context, KRB5_PREAUTH_FAILED,
                                   "OTP_yubikey can not be given twice\n");
            return KRB5_PREAUTH_FAILED;
        }

        otp_ctx->otp = strdup(value);
        if (otp_ctx->otp == NULL) {
            krb5_set_error_message(context, KRB5_PREAUTH_FAILED,
                                   "Could not dublicate OTP_yubikey value\n");
            return ENOMEM;
        }

#ifdef DEBUG 
        fprintf(stderr, "Got Yubikey OTP [%s]\n", otp_ctx->otp);
#endif
    }

    return 0;
}

static krb5_error_code
process_preauth(krb5_context context, void *plugin_context,
                void *request_context, krb5_get_init_creds_opt *opt,
                preauth_get_client_data_proc get_data_proc,
                struct _krb5_preauth_client_rock *rock, krb5_kdc_req *request,
                krb5_data *encoded_request_body,
                krb5_data *encoded_previous_request, krb5_pa_data *padata,
                krb5_prompter_fct prompter, void *prompter_data,
                preauth_get_as_key_proc gak_fct, void *gak_data,
                krb5_data *salt, krb5_data *s2kparams, krb5_keyblock *as_key,
                krb5_pa_data ***out_padata)
{
    krb5_error_code retval = 0;
    krb5_keyblock *armor_key = NULL;
    krb5_pa_data *pa = NULL;
    krb5_pa_data **pa_array = NULL;
    struct yubikey_otp_ctx *otp_ctx = plugin_context;
    krb5_pa_otp_req otp_req;
    krb5_data *encoded_otp_req = NULL;
    krb5_pa_otp_challenge *otp_challenge = NULL;
    krb5_data encoded_otp_challenge;

    if (otp_ctx->otp == NULL) {
        return 0;
    }

    retval = fast_get_armor_key(context, get_data_proc, rock, &armor_key);
    if (retval || armor_key == NULL) {
        return 0;
    }

    if (padata->length != 0) {
#ifdef DEBUG 
        fprintf(stderr, "Got [%d] bytes padata\n", padata->length);
#endif

        encoded_otp_challenge.data = (char *) padata->contents;
        encoded_otp_challenge.length = padata->length;
        retval = decode_krb5_pa_otp_challenge(&encoded_otp_challenge, &otp_challenge);
        if (retval != 0) {
            return retval;
        }
    }

    pa = calloc(1, sizeof(krb5_pa_data));
    if (pa == NULL) {
        retval = ENOMEM;
        goto done;
    }

    pa_array = calloc(2, sizeof(krb5_pa_data *));
    if (pa_array == NULL) {
        retval = ENOMEM;
        goto done;
    }

    memset(&otp_req, 0, sizeof(otp_req));

    otp_req.otp_value.data = otp_ctx->otp;
    otp_req.otp_value.length = strlen(otp_ctx->otp);

    retval = encode_krb5_pa_otp_req(&otp_req, &encoded_otp_req);
    if (retval != 0) {
        goto done;
    }

    pa->length = encoded_otp_req->length;
    pa->contents = (unsigned char *) encoded_otp_req->data;
    pa->pa_type = KRB5_PADATA_OTP_REQUEST;

    pa_array[0] = pa;
    *out_padata = pa_array;


    krb5_free_keyblock(context, armor_key);
    return 0;

done:
    free(pa_array);
    free(pa);

    return retval;
}

static int
server_get_flags(krb5_context kcontext, krb5_preauthtype pa_type)
{
    return 0;
}

static krb5_error_code
server_init(krb5_context context,
            void **plugin_context,
            const char** realmnames)
{
    int ret;
    struct yubikey_server_ctx *ctx = NULL;

    ctx = calloc(1, sizeof(*ctx));
    if (ctx == NULL) {
        return ENOMEM;
    }

    ret = ykclient_init(&ctx->yk_ctx);
    if (ret != YKCLIENT_OK) {
#ifdef DEBUG
        krb5_klog_syslog(LOG_INFO, "ykclient_init failed\n");
#endif
        return EFAULT;
    }

/* TODO: */
/* set URL template from krb5.conf */
/* set client id and key from krb5.conf */
    ykclient_set_client_b64(ctx->yk_ctx, 5047, "T0tSAvojStskT+d4SktMMA4Ly3E=");

    *plugin_context = ctx;

    return 0;
}

static void
server_fini(krb5_context context,
            void *plugin_context)
{
    struct yubikey_server_ctx *ctx = plugin_context;

    ykclient_done(&ctx->yk_ctx);
}

static krb5_error_code
server_get_edata(krb5_context context,
                 krb5_kdc_req *request,
                 struct _krb5_db_entry_new *client,
                 struct _krb5_db_entry_new *server,
                 preauth_get_entry_data_proc server_get_entry_data,
                 void *pa_module_context,
                 krb5_pa_data *data)
{
    krb5_error_code retval = 0;
    krb5_keyblock *armor_key = NULL;
    krb5_pa_otp_challenge otp_challenge;
    krb5_data *encoded_otp_challenge = NULL;

    retval = fast_kdc_get_armor_key(context, server_get_entry_data, request,
                                    client, &armor_key);
    if (retval != 0 || armor_key == NULL) {
        krb5_free_keyblock(context, armor_key);
        return EINVAL;
    }

    memset(&otp_challenge, 0, sizeof(otp_challenge));
/* "This nonce string MUST be as long as the longest key length of the
 * symmetric key types that the KDC supports and MUST be chosen randomly."
 *
 * FIXME: how do I find out the length of the longest key? I take 256 bits for
 * a start. */
    otp_challenge.nonce.length = 32;
    otp_challenge.nonce.data = (char *) malloc(otp_challenge.nonce.length + 1);
    if (otp_challenge.nonce.data == NULL) {
#ifdef DEBUG
        krb5_klog_syslog(LOG_INFO, "malloc failed\n");
#endif
        return ENOMEM;
    }
    retval = krb5_c_random_make_octets(context, &otp_challenge.nonce);
    if(retval != 0) {
#ifdef DEBUG
        krb5_klog_syslog(LOG_INFO, "krb5_c_random_make_octets failed\n");
#endif
        return retval;
    }

    otp_challenge.otp_keyinfo.flags = -1;

    retval = encode_krb5_pa_otp_challenge(&otp_challenge, &encoded_otp_challenge);
    if (retval != 0) {
#ifdef DEBUG
        krb5_klog_syslog(LOG_INFO, "encode_krb5_pa_otp_challenge failed\n");
#endif
        return retval;
    }

    data->contents = (krb5_octet *) encoded_otp_challenge->data;
    data->length = encoded_otp_challenge->length;
    return 0;
}

static krb5_error_code
server_verify_preauth(krb5_context context, struct _krb5_db_entry_new *client,
                   krb5_data *req_pkt, krb5_kdc_req *request,
                   krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,
                   preauth_get_entry_data_proc get_entry_proc,
                   void *pa_module_context, void **pa_request_context,
                   krb5_data **e_data, krb5_authdata ***authz_data)
{
    krb5_pa_otp_req *otp_req;
    krb5_error_code retval = 0;
    krb5_data encoded_otp_req;
    struct yubikey_server_ctx *ctx = pa_module_context;
    char *otp;
    int ret;

    encoded_otp_req.length = data->length;
    encoded_otp_req.data = (char *) data->contents;

    retval = decode_krb5_pa_otp_req(&encoded_otp_req, &otp_req);
    if (retval != 0) {
        return KRB5KDC_ERR_PREAUTH_FAILED;
    }

    krb5_klog_syslog(LOG_INFO, "Yubikey (%.*s)", otp_req->otp_value.length,
                                                 otp_req->otp_value.data);
    otp = strndup(otp_req->otp_value.data, otp_req->otp_value.length);
    if (otp == NULL) {
#ifdef DEBUG
        krb5_klog_syslog(LOG_INFO, "strndup failed\n");
#endif
        return ENOMEM;
    }

    ret = ykclient_request (ctx->yk_ctx, otp);
    free(otp);

    krb5_klog_syslog(LOG_INFO, "Yubikey auth result: [%s]",
                               ykclient_strerror(ret));


    if (ret != YKCLIENT_OK) {
        return KRB5KDC_ERR_PREAUTH_FAILED;
    }

    return 0;
}

krb5_preauthtype supported_pa_types[] = {
    KRB5_PADATA_OTP_REQUEST, 0};

struct krb5plugin_preauth_server_ftable_v1 preauthentication_server_1 = {
    "Yubikey OPT",
    &supported_pa_types[0],
    server_init,
    server_fini,
    server_get_flags,
    server_get_edata,
    server_verify_preauth,
    NULL,
    NULL
};

struct krb5plugin_preauth_client_ftable_v1 preauthentication_client_1 = {
    "Yubikey OTP",                /* name */
    &supported_pa_types[0],
    NULL,                    /* enctype_list */
    cli_init,                    /* plugin init function */
    cli_fini,                    /* plugin fini function */
    preauth_flags,
    NULL,                    /* request init function */
    NULL,                    /* request fini function */
    process_preauth,
    NULL,                    /* try_again function */
    get_gic_opts             /* get init creds opt function */
};
