/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/* include/krb5.h - General definitions for Kerberos version 5.
 *
 * Copyright 1989,1990,1995,2001, 2003, 2007, 2011 by the Massachusetts Institute of Technology.
 * All Rights Reserved.
 *
 * Export of this software from the United States of America may
 *   require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  Furthermore if you modify this software you must label
 * your software as modified software and not distribute it in such a
 * fashion that it might be confused with the original M.I.T. software.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 */

/*
 * Copyright (C) 1998 by the FundsXpress, INC.
 *
 * All rights reserved.
 *
 * Export of this software from the United States of America may require
 * a specific license from the United States Government.  It is the
 * responsibility of any person or organization contemplating export to
 * obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of FundsXpress. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  FundsXpress makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef KRB5_GENERAL__
#define KRB5_GENERAL__

/* By default, do not expose deprecated interfaces. */
#ifndef KRB5_DEPRECATED
#define KRB5_DEPRECATED 0
#endif

#if defined(__MACH__) && defined(__APPLE__)
#       include <TargetConditionals.h>
#    if TARGET_RT_MAC_CFM
#       error "Use KfM 4.0 SDK headers for CFM compilation."
#    endif
#endif

#if defined(_MSDOS) || defined(_WIN32)
#include <win-mac.h>
#endif

#ifndef KRB5_CONFIG__
#ifndef KRB5_CALLCONV
#define KRB5_CALLCONV
#define KRB5_CALLCONV_C
#endif /* !KRB5_CALLCONV */
#endif /* !KRB5_CONFIG__ */

#ifndef KRB5_CALLCONV_WRONG
#define KRB5_CALLCONV_WRONG
#endif

#ifndef THREEPARAMOPEN
#define THREEPARAMOPEN(x,y,z) open(x,y,z)
#endif

#define KRB5_OLD_CRYPTO

#include <stdlib.h>
#include <limits.h>             /* for *_MAX */
#include <stdarg.h>

#ifndef KRB5INT_BEGIN_DECLS
#if defined(__cplusplus)
#define KRB5INT_BEGIN_DECLS     extern "C" {
#define KRB5INT_END_DECLS       }
#else
#define KRB5INT_BEGIN_DECLS
#define KRB5INT_END_DECLS
#endif
#endif

KRB5INT_BEGIN_DECLS

#if TARGET_OS_MAC
#    pragma pack(push,2)
#endif

#if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) >= 30203
# define KRB5_ATTR_DEPRECATED __attribute__((deprecated))
#elif defined _WIN32
# define KRB5_ATTR_DEPRECATED __declspec(deprecated)
#else
# define KRB5_ATTR_DEPRECATED
#endif

/* from profile.h */
struct _profile_t;
/* typedef struct _profile_t *profile_t; */

/*
 * begin wordsize.h
 */

/*
 * Word-size related definition.
 */

typedef unsigned char   krb5_octet;

#if INT_MAX == 0x7fff
typedef int     krb5_int16;
typedef unsigned int    krb5_ui_2;
#elif SHRT_MAX == 0x7fff
typedef short   krb5_int16;
typedef unsigned short  krb5_ui_2;
#else
#error undefined 16 bit type
#endif

#if INT_MAX == 0x7fffffffL
typedef int     krb5_int32;
typedef unsigned int    krb5_ui_4;
#elif LONG_MAX == 0x7fffffffL
typedef long    krb5_int32;
typedef unsigned long   krb5_ui_4;
#elif SHRT_MAX == 0x7fffffffL
typedef short   krb5_int32;
typedef unsigned short  krb5_ui_4;
#else
#error: undefined 32 bit type
#endif

#define VALID_INT_BITS    INT_MAX
#define VALID_UINT_BITS   UINT_MAX

#define KRB5_INT32_MAX  2147483647
/* this strange form is necessary since - is a unary operator, not a sign
   indicator */
#define KRB5_INT32_MIN  (-KRB5_INT32_MAX-1)

#define KRB5_INT16_MAX 65535
/* this strange form is necessary since - is a unary operator, not a sign
   indicator */
#define KRB5_INT16_MIN  (-KRB5_INT16_MAX-1)

/*
 * end wordsize.h
 */

/*
 * begin "base-defs.h"
 */

/*
 * Basic definitions for Kerberos V5 library
 */

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE    1
#endif

typedef unsigned int krb5_boolean;
typedef unsigned int krb5_msgtype;
typedef unsigned int krb5_kvno;

typedef krb5_int32 krb5_addrtype;
typedef krb5_int32 krb5_enctype;
typedef krb5_int32 krb5_cksumtype;
typedef krb5_int32 krb5_authdatatype;
typedef krb5_int32 krb5_keyusage;
typedef krb5_int32 krb5_cryptotype;

typedef krb5_int32      krb5_preauthtype; /* This may change, later on */
typedef krb5_int32      krb5_flags;
typedef krb5_int32      krb5_timestamp;
typedef krb5_int32      krb5_error_code;
typedef krb5_int32      krb5_deltat;

typedef krb5_error_code krb5_magic;

typedef struct _krb5_data {
    krb5_magic magic;
    unsigned int length;
    char *data;
} krb5_data;

typedef struct _krb5_octet_data {
    krb5_magic magic;
    unsigned int length;
    krb5_octet *data;
} krb5_octet_data;

/*
 * Hack length for crypto library to use the afs_string_to_key It is
 * equivalent to -1 without possible sign extension
 * We also overload for an unset salt type length - which is also -1, but
 * hey, why not....
 */
#define SALT_TYPE_AFS_LENGTH UINT_MAX
#define SALT_TYPE_NO_LENGTH  UINT_MAX

typedef void * krb5_pointer;
typedef void const * krb5_const_pointer;

typedef struct krb5_principal_data {
    krb5_magic magic;
    krb5_data realm;
    krb5_data *data;            /**< An array of strings */
    krb5_int32 length;
    krb5_int32 type;
} krb5_principal_data;

typedef krb5_principal_data * krb5_principal;

/*
 * Per V5 spec on definition of principal types
 */

/* Name type not known */
#define KRB5_NT_UNKNOWN                 0
/* Just the name of the principal as in DCE, or for users */
#define KRB5_NT_PRINCIPAL               1
/* Service and other unique instance (krbtgt) */
#define KRB5_NT_SRV_INST                2
/* Service with host name as instance (telnet, rcommands) */
#define KRB5_NT_SRV_HST                 3
/* Service with host as remaining components */
#define KRB5_NT_SRV_XHST                4
/* Unique ID */
#define KRB5_NT_UID                     5
/* PKINIT */
#define KRB5_NT_X500_PRINCIPAL          6
/* Name in form of SMTP email name */
#define KRB5_NT_SMTP_NAME               7
/* Windows 2000 UPN */
#define KRB5_NT_ENTERPRISE_PRINCIPAL    10
#define KRB5_NT_WELLKNOWN               11
/* First component of NT_WELLKNOWN principals */
#define KRB5_WELLKNOWN_NAMESTR          "WELLKNOWN"
/* Windows 2000 UPN and SID */
#define KRB5_NT_MS_PRINCIPAL            -128
/* NT 4 style name */
#define KRB5_NT_MS_PRINCIPAL_AND_ID     -129
/* NT 4 style name and SID */
#define KRB5_NT_ENT_PRINCIPAL_AND_ID    -130

/* constant version thereof: */
typedef const krb5_principal_data *krb5_const_principal;

#define krb5_princ_realm(context, princ) (&(princ)->realm)
#define krb5_princ_set_realm(context, princ,value) ((princ)->realm = *(value))
#define krb5_princ_set_realm_length(context, princ,value) (princ)->realm.length = (value)
#define krb5_princ_set_realm_data(context, princ,value) (princ)->realm.data = (value)
#define krb5_princ_size(context, princ) (princ)->length
#define krb5_princ_type(context, princ) (princ)->type
#define krb5_princ_name(context, princ) (princ)->data
#define krb5_princ_component(context, princ,i)  \
    (((i) < krb5_princ_size(context, princ))    \
     ? (princ)->data + (i)                      \
     : NULL)

/*
 * Constants for realm referrals.
 */
#define        KRB5_REFERRAL_REALM      ""

/*
 * Referral-specific functions.
 */
krb5_boolean KRB5_CALLCONV krb5_is_referral_realm(const krb5_data *r);

/* Both these functions return constant storage that must not be freed. */
const krb5_data *KRB5_CALLCONV krb5_anonymous_realm(void);
krb5_const_principal KRB5_CALLCONV krb5_anonymous_principal(void);

#define KRB5_ANONYMOUS_REALMSTR "WELLKNOWN:ANONYMOUS"
#define KRB5_ANONYMOUS_PRINCSTR "ANONYMOUS" /* wellknown name type */
/*
 * end "base-defs.h"
 */

/*
 * begin "hostaddr.h"
 */

/** structure for address */
typedef struct _krb5_address {
    krb5_magic magic;
    krb5_addrtype addrtype;
    unsigned int length;
    krb5_octet *contents;
} krb5_address;

/* per Kerberos v5 protocol spec */
#define ADDRTYPE_INET           0x0002
#define ADDRTYPE_CHAOS          0x0005
#define ADDRTYPE_XNS            0x0006
#define ADDRTYPE_ISO            0x0007
#define ADDRTYPE_DDP            0x0010
#define ADDRTYPE_NETBIOS        0x0014
#define ADDRTYPE_INET6          0x0018
/* not yet in the spec... */
#define ADDRTYPE_ADDRPORT       0x0100
#define ADDRTYPE_IPPORT         0x0101

/* macros to determine if a type is a local type */
#define ADDRTYPE_IS_LOCAL(addrtype) (addrtype & 0x8000)

/*
 * end "hostaddr.h"
 */


struct _krb5_context;
typedef struct _krb5_context * krb5_context;

struct _krb5_auth_context;
typedef struct _krb5_auth_context * krb5_auth_context;

struct _krb5_cryptosystem_entry;

/*
 * begin "encryption.h"
 */

/** @brief  Exposed contents of a key. */
typedef struct _krb5_keyblock {
    krb5_magic magic;
    krb5_enctype enctype;
    unsigned int length;
    krb5_octet *contents;
} krb5_keyblock;

/**
 * @brief Opaque identifier for a key.
 *
 * Use with the krb5_k APIs for better
 * performance for repeated operations with the same key usage.  Key
 * identifiers must not be used simultaneously within multiple
 * threads, as they may contain mutable internal state and are not
 * mutex-protected.
 */
struct krb5_key_st;
typedef struct krb5_key_st *krb5_key;

#ifdef KRB5_OLD_CRYPTO
typedef struct _krb5_encrypt_block {
    krb5_magic magic;
    krb5_enctype crypto_entry;          /* to call krb5_encrypt_size, you need
                                           this.  it was a pointer, but it
                                           doesn't have to be.  gross. */
    krb5_keyblock *key;
} krb5_encrypt_block;
#endif

typedef struct _krb5_checksum {
    krb5_magic magic;
    krb5_cksumtype checksum_type;       /* checksum type */
    unsigned int length;
    krb5_octet *contents;
} krb5_checksum;

typedef struct _krb5_enc_data {
    krb5_magic magic;
    krb5_enctype enctype;
    krb5_kvno kvno;
    krb5_data ciphertext;
} krb5_enc_data;

typedef struct _krb5_crypto_iov {
    krb5_cryptotype flags;
    krb5_data data;
} krb5_crypto_iov;

/* per Kerberos v5 protocol spec */
#define ENCTYPE_NULL            0x0000
#define ENCTYPE_DES_CBC_CRC     0x0001  /* DES cbc mode with CRC-32 */
#define ENCTYPE_DES_CBC_MD4     0x0002  /* DES cbc mode with RSA-MD4 */
#define ENCTYPE_DES_CBC_MD5     0x0003  /* DES cbc mode with RSA-MD5 */
#define ENCTYPE_DES_CBC_RAW     0x0004  /* DES cbc mode raw */
/* XXX deprecated? */
#define ENCTYPE_DES3_CBC_SHA    0x0005  /* DES-3 cbc mode with NIST-SHA */
#define ENCTYPE_DES3_CBC_RAW    0x0006  /* DES-3 cbc mode raw */
#define ENCTYPE_DES_HMAC_SHA1   0x0008
/* PKINIT */
#define ENCTYPE_DSA_SHA1_CMS    0x0009  /* DSA with SHA1, CMS signature */
#define ENCTYPE_MD5_RSA_CMS     0x000a  /* MD5 with RSA, CMS signature */
#define ENCTYPE_SHA1_RSA_CMS    0x000b  /* SHA1 with RSA, CMS signature */
#define ENCTYPE_RC2_CBC_ENV     0x000c  /* RC2 cbc mode, CMS enveloped data */
#define ENCTYPE_RSA_ENV         0x000d  /* RSA encryption, CMS enveloped data */
#define ENCTYPE_RSA_ES_OAEP_ENV 0x000e  /* RSA w/OEAP encryption, CMS enveloped data */
#define ENCTYPE_DES3_CBC_ENV    0x000f  /* DES-3 cbc mode, CMS enveloped data */

#define ENCTYPE_DES3_CBC_SHA1   0x0010
#define ENCTYPE_AES128_CTS_HMAC_SHA1_96 0x0011
#define ENCTYPE_AES256_CTS_HMAC_SHA1_96 0x0012
#define ENCTYPE_ARCFOUR_HMAC    0x0017
#define ENCTYPE_ARCFOUR_HMAC_EXP 0x0018
#define ENCTYPE_UNKNOWN         0x01ff

#define CKSUMTYPE_CRC32         0x0001
#define CKSUMTYPE_RSA_MD4       0x0002
#define CKSUMTYPE_RSA_MD4_DES   0x0003
#define CKSUMTYPE_DESCBC        0x0004
/* des-mac-k */
/* rsa-md4-des-k */
#define CKSUMTYPE_RSA_MD5       0x0007
#define CKSUMTYPE_RSA_MD5_DES   0x0008
#define CKSUMTYPE_NIST_SHA      0x0009
#define CKSUMTYPE_HMAC_SHA1_DES3        0x000c
#define CKSUMTYPE_HMAC_SHA1_96_AES128   0x000f
#define CKSUMTYPE_HMAC_SHA1_96_AES256   0x0010
#define CKSUMTYPE_MD5_HMAC_ARCFOUR -137 /*Microsoft netlogon cksumtype*/
#define CKSUMTYPE_HMAC_MD5_ARCFOUR -138 /*Microsoft md5 hmac cksumtype*/

/* The following are entropy source designations. Whenever
 * krb5_C_random_add_entropy is called, one of these source  ids is passed
 * in.  This  allows the library  to better estimate bits of
 * entropy in the sample and to keep track of what sources of entropy have
 * contributed enough entropy.  Sources marked internal MUST NOT be
 * used by applications outside the Kerberos library
 */

enum {
    KRB5_C_RANDSOURCE_OLDAPI = 0, /*calls to krb5_C_RANDOM_SEED (INTERNAL)*/
    KRB5_C_RANDSOURCE_OSRAND = 1, /* /dev/random or equivalent (internal)*/
    KRB5_C_RANDSOURCE_TRUSTEDPARTY = 2, /* From KDC or other trusted party*/
    /*This source should be used carefully; data in this category
     * should be from a third party trusted to give random bits
     * For example keys issued by the KDC in the application server.
     */
    KRB5_C_RANDSOURCE_TIMING = 3, /* Timing of operations*/
    KRB5_C_RANDSOURCE_EXTERNAL_PROTOCOL = 4, /*Protocol data possibly from attacker*/
    KRB5_C_RANDSOURCE_MAX = 5 /*Do not use; maximum source ID*/
};

#ifndef krb5_roundup
/* round x up to nearest multiple of y */
#define krb5_roundup(x, y) ((((x) + (y) - 1)/(y))*(y))
#endif /* roundup */

/* macro function definitions to help clean up code */

#if 1
#define krb5_x(ptr,args) ((ptr)?((*(ptr)) args):(abort(),1))
#define krb5_xc(ptr,args) ((ptr)?((*(ptr)) args):(abort(),(char*)0))
#else
#define krb5_x(ptr,args) ((*(ptr)) args)
#define krb5_xc(ptr,args) ((*(ptr)) args)
#endif

 /**
 * @brief Encrypt data using a key.
 *
 * @param context                 Context structure [input, output]
 * @param key                     Key value from key table, ticket, etc. [input]
 * @param usage                   Key usage [input]
 * @param cipher_state            Cipher state [input]
 * @param input                   Data to be encrypted [input]
 * @param output                  Encrypted data [output]
 *
 * @retval
 *  0     Success
 * @retval
 * KRB5_BAD_ENCTYPE      Bad encryption type
 * @return
 * Kerberos error codes
 *
 * @sa enctype
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_c_encrypt(krb5_context context, const krb5_keyblock *key,
               krb5_keyusage usage, const krb5_data *cipher_state,
               const krb5_data *input, krb5_enc_data *output);

/**
 * @brief Decrypt data using a key.
 *
 * @param context           Context structure [input, output]
 * @param key               Key value from key table, ticket, etc. [input]
 * @param usage             Key usage [input]
 * @param cipher_state      Cipher state [input]
 * @param input             Encrypted data [input]
 * @param output            Decrypted data [output]
 *
 * @retval
 * 0 Success
 * @retval
 * KRB5_BAD_ENCTYPE      Bad encryption type
 * @return
 * Kerberos error codes
 *
 * @sa keyusage
 */

krb5_error_code KRB5_CALLCONV
krb5_c_decrypt(krb5_context context, const krb5_keyblock *key,
               krb5_keyusage usage, const krb5_data *cipher_state,
               const krb5_enc_data *input, krb5_data *output);

/**
 * @brief Compute the length of the ciphertext produced by encrypting @a inputlen bytes.
 *
 * @param context               Context structure [input, output]
 * @param enctype               Encryption type [input]
 * @param inputlen              Length of encrypted data [input]
 * @param length                Length of unecrypted data [output]
 *
 * @retval
 * 0    Success
 * @retval
 * KRB5_BAD_ENCTYPE      Bad encryption type
 * @return
 * Kerberos error codes
 */

krb5_error_code KRB5_CALLCONV
krb5_c_encrypt_length(krb5_context context, krb5_enctype enctype,
                      size_t inputlen, size_t *length);

/**
 * @brief Write the block size for the specified encryption type into the @a size_t pointed to by @a blocksize.
 *
 * @param context         Context structure [input, output]
 * @param enctype         Encryption type [input]
 * @param blocksize       Attribute of encryption system [output]
 *
 * @retval
 *  0   Success
 * @retval
 *  KRB5_BAD_ENCTYPE         Bad encryption type
 * @retval
 *  ENOMEM                   Insufficient memory
 * @return
 * Kerberos error codes
 *
 * @sa enctype
 */
krb5_error_code KRB5_CALLCONV
krb5_c_block_size(krb5_context context, krb5_enctype enctype,
                  size_t *blocksize);

/**
 * @brief Write the length of the specified key to keylength.
 *
 * @param context              Context structure [input, output]
 * @param enctype              Encryption type [input]
 * @param keybytes             Number of bytes required to make a key [input]
 * @param keylength            Length of final key
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_c_keylengths(krb5_context context, krb5_enctype enctype,
                  size_t *keybytes, size_t *keylength);

/**
 * @brief Initialize a new cipher state for @a enc_type in the specified @c _krb5_keyblock.
 *
 * @param context             Context structure [input, output]
 * @param key                 Key [input]
 * @param usage               Usage [input]
 * @param new_state           New cipher state [output]
 *
 * @note @a new_state contains the new cipher state.
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_c_init_state(krb5_context context, const krb5_keyblock *key,
                  krb5_keyusage usage, krb5_data *new_state);

/**
 * @brief  Free a cipher state previously allocated by krb5_c_init_state().
 *
 * @param context           Context structure [input, output]
 * @param key               Key [input]
 * @param state             Cipher state to be freed [input]
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */

krb5_error_code KRB5_CALLCONV
krb5_c_free_state(krb5_context context, const krb5_keyblock *key,
                  krb5_data *state);

/**
 * @brief Generate pseudo-random bytes from @a input.
 *
 * @param context           Context structure [input, output]
 * @param keyblock          Key [input]
 * @param input             Input data [input]
 * @param output            Output data [output]
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */

krb5_error_code KRB5_CALLCONV
krb5_c_prf(krb5_context context, const krb5_keyblock *keyblock, krb5_data *input, krb5_data *output);

/**
 * @brief Get the number of pseudo-random bytes output by krb5_c_prf() for the specified @a enctype.
 *
 * @param context           Context structure [input, output]
 * @param enctype           Encryption type [input]
 * @param len               Number of bytes for @a enctype [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */

krb5_error_code KRB5_CALLCONV
krb5_c_prf_length(krb5_context context, krb5_enctype enctype, size_t *len);

/**
 * @return Returns KRB-FX-CF2 in a newly allocated
 * keyblock on success or an error code on error.
 *
 * This function is simple in that it assumes
 * pepper1 and pepper2 are C strings with no
 * internal nulls and that the enctype of the
 * result will be the same as that of k1.  Both
 * of these assumptions are true of current
 * specs.
 */
krb5_error_code KRB5_CALLCONV
krb5_c_fx_cf2_simple(krb5_context context,
                     krb5_keyblock *k1, const char *pepper1,
                     krb5_keyblock *k2, const char *pepper2,
                     krb5_keyblock **out);

/**
 * @brief Create a key from @a random_key.
 *
 * @param context               Context structure [input, output]
 * @param enctype               Encryption type [input]
 * @param k5_random_key         Pointer to an allocated and initialized keyblock [output]
 *
 * The @a length field in @c _krb5_c_keylength ensures that @a random_key->contents points to an allocated buffer
 * of the correct length.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0  Success
 * @retval
 *  KRB5_BAD_ENCTYPE         Bad encryption type
 * @retval
 *  ENOMEM                   Insufficient memory
 * @return
 * Kerberos error codes
 */

krb5_error_code KRB5_CALLCONV
krb5_c_make_random_key(krb5_context context, krb5_enctype enctype,
                       krb5_keyblock *k5_random_key);

/**
 * @param context               Context structure [input, output]
 * @param enctype               Encryption type [input]
 * @param random_data           Pointer to @c _krb5_data structure [input]
 * @param k5_random_key         Pointer to an allocated and initialized keyblock [output]
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_c_random_to_key(krb5_context context, krb5_enctype enctype,
                     krb5_data *random_data, krb5_keyblock *k5_random_key);

/**
 * @brief Add entropy to the pseudo-random number generator.
 *
 * @param context               Context structure [input, output]
 * @param randsource            Entropy source [input]
 * @param data                  Data [input, output]
 *
 * @note  This might cause the @c PRNG to be reseeded, although this is not guaranteed.
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 *
 * @sa randsource
 */
krb5_error_code KRB5_CALLCONV
krb5_c_random_add_entropy(krb5_context context, unsigned int randsource,
                          const krb5_data *data);

/**
 * @brief Generate pseudo-random bytes using entropy from OS.
 *
 * @param context           Context structure [input, output]
 * @param data              Random data [output]
 *
 * @a data->length specifies the number of bytes to generate and @a data->data points to an allocated buffer of the correct length.
 *
 * @retval
 *  0                            Success
 * @retval
 *  KRB5_CRYPTO_INTERNAL         Cryptosystem internal error
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_c_random_make_octets(krb5_context context, krb5_data *data);

/**
 * @brief Collect entropy from the OS if possible.
 *
 * @a strong requests that as strong
 * of a source of entropy  as available be used.  Setting @a strong may
 * increase the probability of blocking and should not  be used for normal
 * applications.  Good uses include seeding the PRNG for kadmind
 * and realm setup.
 *
 * @param context            Context structure [input, output]
 * @param strong             Strongest available source of entropy [input]
 * @param success            1 if OS provides entropy, 0 if OS did not provide entropy [output]
 *
 * @note If @a strong is non-zero, this function attempts to use the strongest available source of entropy.
 *
 * @return
 *  If the OS provided and @a success is non-null,@a success is set to 1
 *
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_c_random_os_entropy(krb5_context context, int strong, int *success);

/**
 * @deprecated.  Replaced by krb5_c_random_add_entropy()
 */
krb5_error_code KRB5_CALLCONV
krb5_c_random_seed(krb5_context context, krb5_data *data);

/**
 * @brief Convert the specified string to a key, using the specified encryption type, salt value, and parameters.
 *
 * @param context                       Context structure [input, output]
 * @param enctype                       Encryption type [input]
 * @param string                        String to be converted [input]
 * @param salt                          Salt value [input]
 * @param key                           Generated key [output]
 *
 * @retval
 *  0    Success
 * @retval
 *  KRB5_BAD_ENCTYPE                Bad encryption type
 *  @retval
 *  KRB5_CRYPTO_INTERNAL            Cryptosystem internal error
 *  @retval
 * ENOMEM                          Insufficient memory
 * @return
 * Kerberos error codes
 *
 * @sa enctype
 * @sa salt
 */
krb5_error_code KRB5_CALLCONV
krb5_c_string_to_key(krb5_context context, krb5_enctype enctype,
                     const krb5_data *string, const krb5_data *salt,
                     krb5_keyblock *key);

/**
 * @brief  Convert a string representation of a key into a @c _krb5_keyblock structure using a specified group of parameters.
 *
 * @param context           Context structure [input, output]
 * @param enctype           Encryption type [input]
 * @param string            String form of the key [input]
 * @param salt              Salt value used in the encryption [input]
 * @param params            Parameters to be used for this conversion [input]
 * @param key               Keyblock [output]
 *
 * @retval
 *  0 Success
 * @retval
 *  KRB5_BAD_ENCTYPE Bad encryption type
 * @retval
 *  KRB5_CRYPTO_INTERNAL Cryptosystem internal error
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 *
 * @sa enctype
 * @sa salt
 */
krb5_error_code KRB5_CALLCONV
krb5_c_string_to_key_with_params(krb5_context context,
                                 krb5_enctype enctype,
                                 const krb5_data *string,
                                 const krb5_data *salt,
                                 const krb5_data *params,
                                 krb5_keyblock *key);

/**
 * @brief Compare two encryption types.
 *
 * @param context            Context structure [input, output]
 * @param e1                 First encryption type [input]
 * @param e2                 Second encryption type [input]
 * @param similar            @c TRUE if types are similar, @c FALSE if types are different [output]
 *
 * @retval
 * TRUE  @a enctypes are similar
 * @retval
 * FALSE @a enctypes are different
 * @retval
 * KRB5_BAD_ENCTYPE     Bad encryption type
 * @return
 * Kerberos error codes
 *
 * @sa enctype
 */
krb5_error_code KRB5_CALLCONV
krb5_c_enctype_compare(krb5_context context, krb5_enctype e1, krb5_enctype e2,
                       krb5_boolean *similar);

/**
 * @brief Compute a checksum.
 *
 * @param context                  Context structure [input, output]
 * @param cksumtype                Checksum type [input]
 * @param key                      Encryption key [input]
 * @param usage                    Usage [input]
 * @param input                    Input data [input]
 * @param cksum                    Checksum [output]
 *
 * @retval
 *  0 Success
 * @retval
 *  KRB5_BAD_ENCTYPE Bad encryption type
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 *
 * @sa cksumtype
 */
krb5_error_code KRB5_CALLCONV
krb5_c_make_checksum(krb5_context context, krb5_cksumtype cksumtype,
                     const krb5_keyblock *key, krb5_keyusage usage,
                     const krb5_data *input, krb5_checksum *cksum);

/**
 * @brief Verify the checksum of data in @a cksum that was created with a @a key using the specified key usage.
 *
 * @param context              Context structure [input, output]
 * @param key                  Encryption key [input]
 * @param usage                Usage [input]
 * @param data                 Data [input]
 * @param cksum                Checksum to be verified [input]
 * @param valid                Non-zero for success, zero for failure [output]
 *
 * @retval
 * Non-zero Success
 * @retval
 *  0  Failure
 * @retval
 *  KRB5_BAD_ENCTYPE    Bad encryption type
 * @retval
 *  KRB5_BAD_MSIZE      Message size is incompatible with encryption type
 * @return
 * Kerberos error codes
 *
 * @sa keyusage
 */
krb5_error_code KRB5_CALLCONV
krb5_c_verify_checksum(krb5_context context, const krb5_keyblock *key,
                       krb5_keyusage usage, const krb5_data *data,
                       const krb5_checksum *cksum, krb5_boolean *valid);

/**
 * @brief Output the checksum length produced by the specified checksum type.
 *
 * @param context               Context structure [input, output]
 * @param cksumtype             Checksum type [input]
 * @param length                Checksum length [output]
 *
 * @retval
 *  0                    Success
 * @retval
 *  KRB5_BAD_ENCTYPE      Bad encryption type
 * @return
 * Kerberos error codes
 *
 * @sa cksumtype
 */
krb5_error_code KRB5_CALLCONV
krb5_c_checksum_length(krb5_context context, krb5_cksumtype cksumtype,
                       size_t *length);

/**
 * @brief Get list of checksum types that match a specified encryption type.
 *
 * @param context           Context structure [input, output]
 * @param enctype           Encryption type [input]
 * @param count             Count of checksums matching the encryption type [output]
 * @param cksumtypes        List of matching checksums [output]
 *
 * This returns only the checksum types that use key derivation.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0   Success
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 *
 * @sa enctype
 * @sa cksumtype
 */
krb5_error_code KRB5_CALLCONV
krb5_c_keyed_checksum_types(krb5_context context, krb5_enctype enctype,
                            unsigned int *count, krb5_cksumtype **cksumtypes);

#define KRB5_KEYUSAGE_AS_REQ_PA_ENC_TS          1
#define KRB5_KEYUSAGE_KDC_REP_TICKET            2
#define KRB5_KEYUSAGE_AS_REP_ENCPART            3
#define KRB5_KEYUSAGE_TGS_REQ_AD_SESSKEY        4
#define KRB5_KEYUSAGE_TGS_REQ_AD_SUBKEY         5
#define KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM        6
#define KRB5_KEYUSAGE_TGS_REQ_AUTH              7
#define KRB5_KEYUSAGE_TGS_REP_ENCPART_SESSKEY   8
#define KRB5_KEYUSAGE_TGS_REP_ENCPART_SUBKEY    9
#define KRB5_KEYUSAGE_AP_REQ_AUTH_CKSUM         10
#define KRB5_KEYUSAGE_AP_REQ_AUTH               11
#define KRB5_KEYUSAGE_AP_REP_ENCPART            12
#define KRB5_KEYUSAGE_KRB_PRIV_ENCPART          13
#define KRB5_KEYUSAGE_KRB_CRED_ENCPART          14
#define KRB5_KEYUSAGE_KRB_SAFE_CKSUM            15
#define KRB5_KEYUSAGE_APP_DATA_ENCRYPT          16
#define KRB5_KEYUSAGE_APP_DATA_CKSUM            17
#define KRB5_KEYUSAGE_KRB_ERROR_CKSUM           18
#define KRB5_KEYUSAGE_AD_KDCISSUED_CKSUM        19
#define KRB5_KEYUSAGE_AD_MTE                    20
#define KRB5_KEYUSAGE_AD_ITE                    21

/* XXX need to register these */

#define KRB5_KEYUSAGE_GSS_TOK_MIC               22
#define KRB5_KEYUSAGE_GSS_TOK_WRAP_INTEG        23
#define KRB5_KEYUSAGE_GSS_TOK_WRAP_PRIV         24

/* Defined in hardware preauth draft */

#define KRB5_KEYUSAGE_PA_SAM_CHALLENGE_CKSUM    25
#define KRB5_KEYUSAGE_PA_SAM_CHALLENGE_TRACKID  26
#define KRB5_KEYUSAGE_PA_SAM_RESPONSE           27

/* Defined in KDC referrals draft */
/**
 * @note There is a conflict with the value of @c KRB5_KEYUSAGE_PA_REFERRAL:
 * it is used for hardware Pre-athentication @a and KDC referrals.
 *
 */
#define KRB5_KEYUSAGE_PA_REFERRAL               26 /* XXX note conflict with above */

/* Defined in [MS-SFU] */
#define KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST  26 /* XXX note conflict with above */
#define KRB5_KEYUSAGE_PA_S4U_X509_USER_REPLY    27 /* XXX note conflict with above */

#define KRB5_KEYUSAGE_AD_SIGNEDPATH             -21
#define KRB5_KEYUSAGE_IAKERB_FINISHED           42
#define KRB5_KEYUSAGE_PA_PKINIT_KX              44
/* define in draft-ietf-krb-wg-otp-preauth */
#define KRB5_KEYUSAGE_PA_OTP_REQUEST            45
/* define in draft-ietf-krb-wg-preauth-framework*/
#define KRB5_KEYUSAGE_FAST_REQ_CHKSUM 50
#define KRB5_KEYUSAGE_FAST_ENC 51
#define KRB5_KEYUSAGE_FAST_REP 52
#define KRB5_KEYUSAGE_FAST_FINISHED 53
#define KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT 54
#define KRB5_KEYUSAGE_ENC_CHALLENGE_KDC 55
#define KRB5_KEYUSAGE_AS_REQ 56

/**
 * @brief Verify that the specified encryption type is a valid Kerberos encryption type.
 *
 * @param ktype           Encryption type [input]
 *
 * @retval
 *  0 invalid
 * @retval
 *  1  valid
 *
 * @sa enctype
 */
krb5_boolean KRB5_CALLCONV
krb5_c_valid_enctype(krb5_enctype ktype);

/**
 * @brief Verify that specified checksum type is a valid Kerberos checksum type.
 *
 * @param ctype                        Checksum type [input]
 *
 * @retval
 *  0 invalid
 * @retval
 *  1  valid
 *
 * @sa cksumtype
 */
krb5_boolean KRB5_CALLCONV
krb5_c_valid_cksumtype(krb5_cksumtype ctype);

/**
 * @brief Test whether a checksum type is collision-proof.
 *
 * @param ctype                        Checksum type [input]
 *
 * @retval
 *   0 Not collision-proof, or checksum type is not in the list
 * @retval
 * 1  Success
 */
krb5_boolean KRB5_CALLCONV
krb5_c_is_coll_proof_cksum(krb5_cksumtype ctype);

/**
 * @brief Test whether a checksum type is keyed.
 *
 * @param ctype                    Checksum type [input]
 *
 * @retval
 *  0       Checksum does not use derived keys, or checksum type is not in the list
 * @retval
 *  1       Checksum uses derived keys
 */
krb5_boolean KRB5_CALLCONV
krb5_c_is_keyed_cksum(krb5_cksumtype ctype);

/* AEAD APIs */
#define KRB5_CRYPTO_TYPE_EMPTY      0   /* [in] ignored */
#define KRB5_CRYPTO_TYPE_HEADER     1   /* [out] header */
#define KRB5_CRYPTO_TYPE_DATA       2   /* [in, out] plaintext */
#define KRB5_CRYPTO_TYPE_SIGN_ONLY  3   /* [in] associated data */
#define KRB5_CRYPTO_TYPE_PADDING    4   /* [out] padding */
#define KRB5_CRYPTO_TYPE_TRAILER    5   /* [out] checksum for encrypt */
#define KRB5_CRYPTO_TYPE_CHECKSUM   6   /* [out] checksum for MIC */
#define KRB5_CRYPTO_TYPE_STREAM     7   /* [in] entire message */

krb5_error_code KRB5_CALLCONV
krb5_c_make_checksum_iov(krb5_context context, krb5_cksumtype cksumtype,
                         const krb5_keyblock *key, krb5_keyusage usage,
                         krb5_crypto_iov *data, size_t num_data);

krb5_error_code KRB5_CALLCONV
krb5_c_verify_checksum_iov(krb5_context context, krb5_cksumtype cksumtype,
                           const krb5_keyblock *key, krb5_keyusage usage,
                           const krb5_crypto_iov *data, size_t num_data,
                           krb5_boolean *valid);

krb5_error_code KRB5_CALLCONV
krb5_c_encrypt_iov(krb5_context context, const krb5_keyblock *key,
                   krb5_keyusage usage, const krb5_data *cipher_state,
                   krb5_crypto_iov *data, size_t num_data);

krb5_error_code KRB5_CALLCONV
krb5_c_decrypt_iov(krb5_context context, const krb5_keyblock *key,
                   krb5_keyusage usage, const krb5_data *cipher_state,
                   krb5_crypto_iov *data, size_t num_data);

krb5_error_code KRB5_CALLCONV
krb5_c_crypto_length(krb5_context context, krb5_enctype enctype,
                     krb5_cryptotype type, unsigned int *size);

krb5_error_code KRB5_CALLCONV
krb5_c_crypto_length_iov(krb5_context context, krb5_enctype enctype,
                         krb5_crypto_iov *data, size_t num_data);

krb5_error_code KRB5_CALLCONV
krb5_c_padding_length(krb5_context context, krb5_enctype enctype,
                      size_t data_length, unsigned int *size);

krb5_error_code KRB5_CALLCONV
krb5_k_create_key(krb5_context context, const krb5_keyblock *key_data,
                  krb5_key *out);

/**
 * Keys are logically immutable and can be "copied" by reference count.
 */
void KRB5_CALLCONV
krb5_k_reference_key(krb5_context context, krb5_key key);

/**
 * @brief Decrement the reference count on a key and free it if it hits zero.
 */
void KRB5_CALLCONV krb5_k_free_key(krb5_context context, krb5_key key);

krb5_error_code KRB5_CALLCONV
krb5_k_key_keyblock(krb5_context context, krb5_key key,
                    krb5_keyblock **key_data);

krb5_enctype KRB5_CALLCONV
krb5_k_key_enctype(krb5_context context, krb5_key key);

krb5_error_code KRB5_CALLCONV
krb5_k_encrypt(krb5_context context, krb5_key key, krb5_keyusage usage,
               const krb5_data *cipher_state, const krb5_data *input,
               krb5_enc_data *output);

krb5_error_code KRB5_CALLCONV
krb5_k_encrypt_iov(krb5_context context, krb5_key key, krb5_keyusage usage,
                   const krb5_data *cipher_state, krb5_crypto_iov *data,
                   size_t num_data);

krb5_error_code KRB5_CALLCONV
krb5_k_decrypt(krb5_context context, krb5_key key, krb5_keyusage usage,
               const krb5_data *cipher_state, const krb5_enc_data *input,
               krb5_data *output);

krb5_error_code KRB5_CALLCONV
krb5_k_decrypt_iov(krb5_context context, krb5_key key, krb5_keyusage usage,
                   const krb5_data *cipher_state, krb5_crypto_iov *data,
                   size_t num_data);

krb5_error_code KRB5_CALLCONV
krb5_k_make_checksum(krb5_context context, krb5_cksumtype cksumtype,
                     krb5_key key, krb5_keyusage usage, const krb5_data *input,
                     krb5_checksum *cksum);

krb5_error_code KRB5_CALLCONV
krb5_k_make_checksum_iov(krb5_context context, krb5_cksumtype cksumtype,
                         krb5_key key, krb5_keyusage usage,
                         krb5_crypto_iov *data, size_t num_data);

krb5_error_code KRB5_CALLCONV
krb5_k_verify_checksum(krb5_context context, krb5_key key, krb5_keyusage usage,
                       const krb5_data *data, const krb5_checksum *cksum,
                       krb5_boolean *valid);

krb5_error_code KRB5_CALLCONV
krb5_k_verify_checksum_iov(krb5_context context, krb5_cksumtype cksumtype,
                           krb5_key key, krb5_keyusage usage,
                           const krb5_crypto_iov *data, size_t num_data,
                           krb5_boolean *valid);

krb5_error_code KRB5_CALLCONV
krb5_k_prf(krb5_context context, krb5_key key, krb5_data *in, krb5_data *out);

#ifdef KRB5_OLD_CRYPTO
/*
 * old cryptosystem routine prototypes.  These are now layered
 * on top of the functions above.
 */
/** @deprecated
 */
krb5_error_code KRB5_CALLCONV
krb5_encrypt(krb5_context context, krb5_const_pointer inptr,
             krb5_pointer outptr, size_t size, krb5_encrypt_block *eblock,
             krb5_pointer ivec);

/** @deprecated Replaced by krb5_c_decrypt()
 */
krb5_error_code KRB5_CALLCONV
krb5_decrypt(krb5_context context, krb5_const_pointer inptr,
             krb5_pointer outptr, size_t size, krb5_encrypt_block *eblock,
             krb5_pointer ivec);

/** @deprecated
 */
krb5_error_code KRB5_CALLCONV
krb5_process_key(krb5_context context, krb5_encrypt_block *eblock,
                 const krb5_keyblock * key);

/** @deprecated
 */
krb5_error_code KRB5_CALLCONV
krb5_finish_key(krb5_context context, krb5_encrypt_block * eblock);

/** @deprecated Replaced by krb5_c_string_to_key()
 */
krb5_error_code KRB5_CALLCONV
krb5_string_to_key(krb5_context context, const krb5_encrypt_block *eblock,
                   krb5_keyblock * keyblock, const krb5_data *data,
                   const krb5_data *salt);

/** @deprecated
 */
krb5_error_code KRB5_CALLCONV
krb5_init_random_key(krb5_context context, const krb5_encrypt_block *eblock,
                     const krb5_keyblock *keyblock, krb5_pointer *ptr);

/** @deprecated
 */
krb5_error_code KRB5_CALLCONV
krb5_finish_random_key(krb5_context context, const krb5_encrypt_block *eblock,
                       krb5_pointer *ptr);

/** @deprecated Replaced by krb5_c_random_key()
 */
krb5_error_code KRB5_CALLCONV
krb5_random_key(krb5_context context, const krb5_encrypt_block *eblock,
                krb5_pointer ptr, krb5_keyblock **keyblock);

/** @deprecated
 */
krb5_enctype KRB5_CALLCONV
krb5_eblock_enctype(krb5_context context, const krb5_encrypt_block *eblock);

/** @deprecated
 */
krb5_error_code KRB5_CALLCONV
krb5_use_enctype(krb5_context context, krb5_encrypt_block *eblock,
                 krb5_enctype enctype);

/** @deprecated Replaced by krb5_c_encrypt_length()
 */
size_t KRB5_CALLCONV
krb5_encrypt_size(size_t length, krb5_enctype crypto);

/** @deprecated Replaced by krb5_c_checksum_length()
 */
size_t KRB5_CALLCONV
krb5_checksum_size(krb5_context context, krb5_cksumtype ctype);

/** @deprecated Replaced by krb5_c_make_checksum()
 */
krb5_error_code KRB5_CALLCONV
krb5_calculate_checksum(krb5_context context, krb5_cksumtype ctype,
                        krb5_const_pointer in, size_t in_length,
                        krb5_const_pointer seed, size_t seed_length,
                        krb5_checksum * outcksum);

/** @deprecated
 */
krb5_error_code KRB5_CALLCONV
krb5_verify_checksum(krb5_context context, krb5_cksumtype ctype,
                     const krb5_checksum * cksum, krb5_const_pointer in,
                     size_t in_length, krb5_const_pointer seed,
                     size_t seed_length);

#endif /* KRB5_OLD_CRYPTO */

/*
 * end "encryption.h"
 */

/*
 * begin "fieldbits.h"
 */

/* kdc_options for kdc_request */
/* options is 32 bits; each host is responsible to put the 4 bytes
   representing these bits into net order before transmission */
/* #define      KDC_OPT_RESERVED        0x80000000 */
#define KDC_OPT_FORWARDABLE             0x40000000
#define KDC_OPT_FORWARDED               0x20000000
#define KDC_OPT_PROXIABLE               0x10000000
#define KDC_OPT_PROXY                   0x08000000
#define KDC_OPT_ALLOW_POSTDATE          0x04000000
#define KDC_OPT_POSTDATED               0x02000000
/* #define      KDC_OPT_UNUSED          0x01000000 */
#define KDC_OPT_RENEWABLE               0x00800000
/* #define      KDC_OPT_UNUSED          0x00400000 */
/* #define      KDC_OPT_RESERVED        0x00200000 */
/* #define      KDC_OPT_RESERVED        0x00100000 */
/* #define      KDC_OPT_RESERVED        0x00080000 */
/* #define      KDC_OPT_RESERVED        0x00040000 */
#define KDC_OPT_CNAME_IN_ADDL_TKT       0x00020000
#define KDC_OPT_CANONICALIZE            0x00010000
#define KDC_OPT_REQUEST_ANONYMOUS       0x00008000
/* #define      KDC_OPT_RESERVED        0x00004000 */
/* #define      KDC_OPT_RESERVED        0x00002000 */
/* #define      KDC_OPT_RESERVED        0x00001000 */
/* #define      KDC_OPT_RESERVED        0x00000800 */
/* #define      KDC_OPT_RESERVED        0x00000400 */
/* #define      KDC_OPT_RESERVED        0x00000200 */
/* #define      KDC_OPT_RESERVED        0x00000100 */
/* #define      KDC_OPT_RESERVED        0x00000080 */
/* #define      KDC_OPT_RESERVED        0x00000040 */
#define KDC_OPT_DISABLE_TRANSITED_CHECK 0x00000020
#define KDC_OPT_RENEWABLE_OK            0x00000010
#define KDC_OPT_ENC_TKT_IN_SKEY         0x00000008
/* #define      KDC_OPT_UNUSED          0x00000004 */
#define KDC_OPT_RENEW                   0x00000002
#define KDC_OPT_VALIDATE                0x00000001

/*
 * Mask of ticket flags in the TGT which should be converted into KDC
 * options when using the TGT to get derivitive tickets.
 *
 *  New mask = KDC_OPT_FORWARDABLE | KDC_OPT_PROXIABLE |
 *             KDC_OPT_ALLOW_POSTDATE | KDC_OPT_RENEWABLE
 */
#define KDC_TKT_COMMON_MASK             0x54800000

/* definitions for ap_options fields */
/* ap_options are 32 bits; each host is responsible to put the 4 bytes
   representing these bits into net order before transmission */
#define AP_OPTS_RESERVED                0x80000000
#define AP_OPTS_USE_SESSION_KEY         0x40000000
#define AP_OPTS_MUTUAL_REQUIRED         0x20000000
/* #define      AP_OPTS_RESERVED        0x10000000 */
/* #define      AP_OPTS_RESERVED        0x08000000 */
/* #define      AP_OPTS_RESERVED        0x04000000 */
/* #define      AP_OPTS_RESERVED        0x02000000 */
/* #define      AP_OPTS_RESERVED        0x01000000 */
/* #define      AP_OPTS_RESERVED        0x00800000 */
/* #define      AP_OPTS_RESERVED        0x00400000 */
/* #define      AP_OPTS_RESERVED        0x00200000 */
/* #define      AP_OPTS_RESERVED        0x00100000 */
/* #define      AP_OPTS_RESERVED        0x00080000 */
/* #define      AP_OPTS_RESERVED        0x00040000 */
/* #define      AP_OPTS_RESERVED        0x00020000 */
/* #define      AP_OPTS_RESERVED        0x00010000 */
/* #define      AP_OPTS_RESERVED        0x00008000 */
/* #define      AP_OPTS_RESERVED        0x00004000 */
/* #define      AP_OPTS_RESERVED        0x00002000 */
/* #define      AP_OPTS_RESERVED        0x00001000 */
/* #define      AP_OPTS_RESERVED        0x00000800 */
/* #define      AP_OPTS_RESERVED        0x00000400 */
/* #define      AP_OPTS_RESERVED        0x00000200 */
/* #define      AP_OPTS_RESERVED        0x00000100 */
/* #define      AP_OPTS_RESERVED        0x00000080 */
/* #define      AP_OPTS_RESERVED        0x00000040 */
/* #define      AP_OPTS_RESERVED        0x00000020 */
/* #define      AP_OPTS_RESERVED        0x00000010 */
/* #define      AP_OPTS_RESERVED        0x00000008 */
/* #define      AP_OPTS_RESERVED        0x00000004 */
#define AP_OPTS_ETYPE_NEGOTIATION       0x00000002
#define AP_OPTS_USE_SUBKEY              0x00000001

#define AP_OPTS_WIRE_MASK               0xfffffff0

/* definitions for ad_type fields. */
#define AD_TYPE_RESERVED        0x8000
#define AD_TYPE_EXTERNAL        0x4000
#define AD_TYPE_REGISTERED      0x2000

#define AD_TYPE_FIELD_TYPE_MASK 0x1fff

/* Ticket flags */
/* flags are 32 bits; each host is responsible to put the 4 bytes
   representing these bits into net order before transmission */
/* #define      TKT_FLG_RESERVED        0x80000000 */
#define TKT_FLG_FORWARDABLE             0x40000000
#define TKT_FLG_FORWARDED               0x20000000
#define TKT_FLG_PROXIABLE               0x10000000
#define TKT_FLG_PROXY                   0x08000000
#define TKT_FLG_MAY_POSTDATE            0x04000000
#define TKT_FLG_POSTDATED               0x02000000
#define TKT_FLG_INVALID                 0x01000000
#define TKT_FLG_RENEWABLE               0x00800000
#define TKT_FLG_INITIAL                 0x00400000
#define TKT_FLG_PRE_AUTH                0x00200000
#define TKT_FLG_HW_AUTH                 0x00100000
#define TKT_FLG_TRANSIT_POLICY_CHECKED  0x00080000
#define TKT_FLG_OK_AS_DELEGATE          0x00040000
#define TKT_FLG_ENC_PA_REP              0x00010000
#define TKT_FLG_ANONYMOUS               0x00008000
/* #define      TKT_FLG_RESERVED        0x00004000 */
/* #define      TKT_FLG_RESERVED        0x00002000 */
/* #define      TKT_FLG_RESERVED        0x00001000 */
/* #define      TKT_FLG_RESERVED        0x00000800 */
/* #define      TKT_FLG_RESERVED        0x00000400 */
/* #define      TKT_FLG_RESERVED        0x00000200 */
/* #define      TKT_FLG_RESERVED        0x00000100 */
/* #define      TKT_FLG_RESERVED        0x00000080 */
/* #define      TKT_FLG_RESERVED        0x00000040 */
/* #define      TKT_FLG_RESERVED        0x00000020 */
/* #define      TKT_FLG_RESERVED        0x00000010 */
/* #define      TKT_FLG_RESERVED        0x00000008 */
/* #define      TKT_FLG_RESERVED        0x00000004 */
/* #define      TKT_FLG_RESERVED        0x00000002 */
/* #define      TKT_FLG_RESERVED        0x00000001 */

/* definitions for lr_type fields. */
#define LR_TYPE_THIS_SERVER_ONLY        0x8000

#define LR_TYPE_INTERPRETATION_MASK     0x7fff

/* definitions for msec direction bit for KRB_SAFE, KRB_PRIV */
#define MSEC_DIRBIT             0x8000
#define MSEC_VAL_MASK           0x7fff

/*
 * end "fieldbits.h"
 */

/*
 * begin "proto.h"
 */

/* Protocol version number */
#define KRB5_PVNO       5

/* Message types */

#define KRB5_AS_REQ     ((krb5_msgtype)10) /* Req for initial authentication */
#define KRB5_AS_REP     ((krb5_msgtype)11) /* Response to KRB_AS_REQ request */
#define KRB5_TGS_REQ    ((krb5_msgtype)12) /* TGS request to server */
#define KRB5_TGS_REP    ((krb5_msgtype)13) /* Response to KRB_TGS_REQ req */
#define KRB5_AP_REQ     ((krb5_msgtype)14) /* application request to server */
#define KRB5_AP_REP     ((krb5_msgtype)15) /* Response to KRB_AP_REQ_MUTUAL */
#define KRB5_SAFE       ((krb5_msgtype)20) /* Safe application message */
#define KRB5_PRIV       ((krb5_msgtype)21) /* Private application message */
#define KRB5_CRED       ((krb5_msgtype)22) /* Credential forwarding message */
#define KRB5_ERROR      ((krb5_msgtype)30) /* Error response */

/* LastReq types */
#define KRB5_LRQ_NONE                   0
#define KRB5_LRQ_ALL_LAST_TGT           1
#define KRB5_LRQ_ONE_LAST_TGT           (-1)
#define KRB5_LRQ_ALL_LAST_INITIAL       2
#define KRB5_LRQ_ONE_LAST_INITIAL       (-2)
#define KRB5_LRQ_ALL_LAST_TGT_ISSUED    3
#define KRB5_LRQ_ONE_LAST_TGT_ISSUED    (-3)
#define KRB5_LRQ_ALL_LAST_RENEWAL       4
#define KRB5_LRQ_ONE_LAST_RENEWAL       (-4)
#define KRB5_LRQ_ALL_LAST_REQ           5
#define KRB5_LRQ_ONE_LAST_REQ           (-5)
#define KRB5_LRQ_ALL_PW_EXPTIME         6
#define KRB5_LRQ_ONE_PW_EXPTIME         (-6)
#define KRB5_LRQ_ALL_ACCT_EXPTIME       7
#define KRB5_LRQ_ONE_ACCT_EXPTIME       (-7)

/* PADATA types */
#define KRB5_PADATA_NONE                0
#define KRB5_PADATA_AP_REQ              1
#define KRB5_PADATA_TGS_REQ             KRB5_PADATA_AP_REQ
#define KRB5_PADATA_ENC_TIMESTAMP       2
#define KRB5_PADATA_PW_SALT             3
#if 0                           /* Not used */
#define KRB5_PADATA_ENC_ENCKEY          4  /* Key encrypted within itself */
#endif
#define KRB5_PADATA_ENC_UNIX_TIME       5  /* timestamp encrypted in key */
#define KRB5_PADATA_ENC_SANDIA_SECURID  6  /* SecurId passcode */
#define KRB5_PADATA_SESAME              7  /* Sesame project */
#define KRB5_PADATA_OSF_DCE             8  /* OSF DCE */
#define KRB5_CYBERSAFE_SECUREID         9  /* Cybersafe */
#define KRB5_PADATA_AFS3_SALT           10 /* Cygnus */
#define KRB5_PADATA_ETYPE_INFO          11 /* Etype info for preauth */
#define KRB5_PADATA_SAM_CHALLENGE       12 /* draft challenge system */
#define KRB5_PADATA_SAM_RESPONSE        13 /* draft challenge system response */
#define KRB5_PADATA_PK_AS_REQ_OLD       14 /* PKINIT */
#define KRB5_PADATA_PK_AS_REP_OLD       15 /* PKINIT */
#define KRB5_PADATA_PK_AS_REQ           16 /* PKINIT */
#define KRB5_PADATA_PK_AS_REP           17 /* PKINIT */
#define KRB5_PADATA_ETYPE_INFO2         19
#define KRB5_PADATA_USE_SPECIFIED_KVNO  20
#define KRB5_PADATA_SVR_REFERRAL_INFO   20 /* Windows 2000 referrals */
#define KRB5_PADATA_SAM_REDIRECT        21
#define KRB5_PADATA_GET_FROM_TYPED_DATA 22
#define KRB5_PADATA_REFERRAL            25 /* draft referral system */
#define KRB5_PADATA_SAM_CHALLENGE_2     30 /* draft challenge system, updated */
#define KRB5_PADATA_SAM_RESPONSE_2      31 /* draft challenge system, updated */
#define KRB5_PADATA_PAC_REQUEST         128 /* include Windows PAC */
#define KRB5_PADATA_FOR_USER            129 /* username protocol transition request */
#define KRB5_PADATA_S4U_X509_USER       130 /* certificate protocol transition request */
#define KRB5_PADATA_FX_COOKIE 133
#define KRB5_PADATA_FX_FAST  136
#define KRB5_PADATA_FX_ERROR 137
#define KRB5_PADATA_ENCRYPTED_CHALLENGE 138
#define KRB5_PADATA_PKINIT_KX 147
#define KRB5_ENCPADATA_REQ_ENC_PA_REP 149

#define KRB5_SAM_USE_SAD_AS_KEY         0x80000000
#define KRB5_SAM_SEND_ENCRYPTED_SAD     0x40000000
#define KRB5_SAM_MUST_PK_ENCRYPT_SAD    0x20000000 /* currently must be zero */

/* Reserved for SPX pre-authentication. */
#define KRB5_PADATA_DASS                16

/* Transited encoding types */
#define KRB5_DOMAIN_X500_COMPRESS       1

/* alternate authentication types */
#define KRB5_ALTAUTH_ATT_CHALLENGE_RESPONSE     64

/* authorization data types */
#define KRB5_AUTHDATA_IF_RELEVANT   1
#define KRB5_AUTHDATA_KDC_ISSUED    4
#define KRB5_AUTHDATA_AND_OR        5
#define KRB5_AUTHDATA_MANDATORY_FOR_KDC 8
#define KRB5_AUTHDATA_INITIAL_VERIFIED_CAS      9
#define KRB5_AUTHDATA_OSF_DCE   64
#define KRB5_AUTHDATA_SESAME    65
#define KRB5_AUTHDATA_WIN2K_PAC 128
#define KRB5_AUTHDATA_ETYPE_NEGOTIATION 129     /* RFC 4537 */
#define KRB5_AUTHDATA_SIGNTICKET        512     /* formerly 142 in krb5 1.8 */
#define KRB5_AUTHDATA_FX_ARMOR 71
/* password change constants */

#define KRB5_KPASSWD_SUCCESS            0
#define KRB5_KPASSWD_MALFORMED          1
#define KRB5_KPASSWD_HARDERROR          2
#define KRB5_KPASSWD_AUTHERROR          3
#define KRB5_KPASSWD_SOFTERROR          4
/* These are Microsoft's extensions in RFC 3244, and it looks like
   they'll become standardized, possibly with other additions.  */
#define KRB5_KPASSWD_ACCESSDENIED       5       /* unused */
#define KRB5_KPASSWD_BAD_VERSION        6
#define KRB5_KPASSWD_INITIAL_FLAG_NEEDED 7      /* unused */

/*
 * end "proto.h"
 */

/* Time set */
/**
 * @brief Ticket start time, end time, and renewal duration.
 */

typedef struct _krb5_ticket_times {
    krb5_timestamp authtime;    /**< Time at which KDC issued the initial ticket that corresponds to this ticket */
                                  /* XXX ? should ktime in KDC_REP == authtime
                                  in ticket? otherwise client can't get this */
    krb5_timestamp starttime;   /**< optional in ticket, if not present, use @a authtime */
    krb5_timestamp endtime;     /**< Ticket expiration time */
    krb5_timestamp renew_till;  /**< Latest time at which renewal of ticket can be valid */
} krb5_ticket_times;

/**  @brief  structure for auth data */
typedef struct _krb5_authdata {
    krb5_magic magic;
    krb5_authdatatype ad_type; /**< ADTYPE */
    unsigned int length;       /**< Length of data  */
    krb5_octet *contents;      /**< Data */
} krb5_authdata;

/**  @brief  structure for transited encoding */
typedef struct _krb5_transited {
    krb5_magic magic;
    krb5_octet tr_type;     /**< Transited encoding type */
    krb5_data tr_contents;  /**< Contents */
} krb5_transited;

 /**
 * @brief  Encrypted part of ticket.
 * @sa tktflag
 * @sa enctype
 *
 */
typedef struct _krb5_enc_tkt_part {
    krb5_magic magic;
    /* to-be-encrypted portion */
    krb5_flags flags;                   /**< flags */
    krb5_keyblock *session;             /**< session key: includes enctype */
    krb5_principal client;              /**< client name/realm */
    krb5_transited transited;           /**< list of transited realms */
    krb5_ticket_times times;            /**< auth, start, end, renew_till */
    krb5_address **caddrs;              /**< array of ptrs to addresses */
    krb5_authdata **authorization_data; /**< auth data */
} krb5_enc_tkt_part;

/**
 * @brief Ticket structure.
 *
 * Ticket structure that holds the C representation of the ticket protocol
 * message and a pointer to the representation of @c _krb5_enc_tkt_part.
 *
 * @sa enctype
 */
typedef struct _krb5_ticket {
    krb5_magic magic;
    /* cleartext portion */
    krb5_principal server;              /**< server name/realm */
    krb5_enc_data enc_part;             /**< encryption type, kvno, encrypted encoding */
    krb5_enc_tkt_part *enc_part2;       /**< ptr to decrypted version, if available */
} krb5_ticket;

/* the unencrypted version */
/**
 * @brief Ticket authenticator.
 *
 * Ticket authenticator: the @c c representation of @c AP-REQ message with decrypted authenticator.
 *
 * @todo ers look up asn.1 types and reformat accordingly
 *
 * @sa aptops
 */

typedef struct _krb5_authenticator {
    krb5_magic magic;
    krb5_principal client;              /**< client name/realm */
    krb5_checksum *checksum;            /**< checksum, includes type, optional */
    krb5_int32 cusec;                   /**< client usec portion */
    krb5_timestamp ctime;               /**< client sec portion */
    krb5_keyblock *subkey;              /**< true session key, optional */
    krb5_ui_4 seq_number;               /**< sequence #, optional */
    krb5_authdata **authorization_data; /**< New add by Ari, auth data */
} krb5_authenticator;

typedef struct _krb5_tkt_authent {
    krb5_magic magic;
    krb5_ticket *ticket;
    krb5_authenticator *authenticator;
    krb5_flags ap_options;
} krb5_tkt_authent;

/**
 * @brief Credentials structure including ticket, session key, and lifetime info.
 *
 * @sa tktflag
 *
 */
typedef struct _krb5_creds {
    krb5_magic magic;
    krb5_principal client;              /**< client's principal identifier */
    krb5_principal server;              /**< server's principal identifier */
    krb5_keyblock keyblock;             /**< session encryption key info */
    krb5_ticket_times times;            /**< lifetime info */
    krb5_boolean is_skey;               /**< true if ticket is encrypted in
                                           another ticket's skey */
    krb5_flags ticket_flags;            /**< flags in ticket */
    krb5_address **addresses;           /**< addrs in ticket */
    krb5_data ticket;                   /**< ticket string itself */
    krb5_data second_ticket;            /**< second ticket, if related to
                                           ticket (via DUPLICATE-SKEY or
                                           ENC-TKT-IN-SKEY) */
    krb5_authdata **authdata;           /**< authorization data */
} krb5_creds;

/**  @brief Last request entry */
typedef struct _krb5_last_req_entry {
    krb5_magic magic;
    krb5_int32 lr_type;   /**< LR type */
    krb5_timestamp value;  /**< Timestamp */
} krb5_last_req_entry;

/**  @brief  Pre-authentication data
  * @sa padata
  */
typedef struct _krb5_pa_data {
    krb5_magic magic;
    krb5_preauthtype  pa_type; /**< Preauthentication data type */
    unsigned int length;       /**< Length of data   */
    krb5_octet *contents;       /**< Data   */
} krb5_pa_data;

/* typed data */
/**
 * The FAST error handling logic currently assumes that this structure and
 * krb5_pa_data * can be safely cast to each other if this structure changes,
 * that code needs to be updated to copy.
 */
typedef struct _krb5_typed_data {
    krb5_magic magic;
    krb5_int32  type;
    unsigned int length;
    krb5_octet *data;
} krb5_typed_data;

/**
 * @brief Representation of KDC-REQ protocol message.
 *
 * @sa kdcopts
 */
typedef struct _krb5_kdc_req {
    krb5_magic magic;
    krb5_msgtype msg_type;              /**< krb5_kdc_req AS_REQ or TGS_REQ? */
    krb5_pa_data **padata;              /**< krb5_kdc_req e.g. encoded AP_REQ */
    /* real body */
    krb5_flags kdc_options;             /**< requested options */
    krb5_principal client;              /**< includes realm; optional */
    krb5_principal server;              /**< includes realm (only used if no client) */
    krb5_timestamp from;                /**< requested starttime */
    krb5_timestamp till;                /**< requested endtime */
    krb5_timestamp rtime;               /**< (optional) requested renew_till */
    krb5_int32 nonce;                   /**< nonce to match request/response */
    int nktypes;                        /**< # of ktypes, must be positive */
    krb5_enctype *ktype;                /**< requested enctype(s) */
    krb5_address **addresses;           /**< requested addresses, optional */
    krb5_enc_data authorization_data;   /**< encrypted auth data; OPTIONAL */
    krb5_authdata **unenc_authdata;     /**< unencrypted auth data, if available */
    krb5_ticket **second_ticket;/**< second ticket array; OPTIONAL */
    /** the following field is added in March 2009; it is a hack so
     * that FAST state can be carried to pre-authentication plugins.
     * A new plugin interface may be a better long-term approach.  It
     * is believed to be safe to extend this structure because it is
     * not found in any public APIs.
     */
    void * kdc_state;
} krb5_kdc_req;

/**
 * @brief Representation of @c EncKDCRepPart protocol message.
 *
 * This is the cleartext message that is encrypted and inserted in @c KDC-REP.
 */

typedef struct _krb5_enc_kdc_rep_part {
    krb5_magic magic;
    /* encrypted part: */
    krb5_msgtype msg_type;              /**< krb5 message type */
    krb5_keyblock *session;             /**< session key */
    krb5_last_req_entry **last_req;     /**< array of ptrs to entries */
    krb5_int32 nonce;                   /**< nonce from request */
    krb5_timestamp key_exp;             /**< expiration date */
    krb5_flags flags;                   /**< ticket flags */
    krb5_ticket_times times;            /**< lifetime info */
    krb5_principal server;              /**< server's principal identifier */
    krb5_address **caddrs;              /**< array of ptrs to addresses, optional */
    krb5_pa_data **enc_padata;          /**< Windows 2000 compat */
} krb5_enc_kdc_rep_part;

/** @brief Representation of  the @c KDC-REP protocol message.
 *
 * @sa padata
 */
typedef struct _krb5_kdc_rep {
    krb5_magic magic;
    /* cleartext part: */
    krb5_msgtype msg_type;              /**< AS_REP or KDC_REP? */
    krb5_pa_data **padata;              /**< preauthentication data from KDC */
    krb5_principal client;              /**< client's principal identifier */
    krb5_ticket *ticket;                /**< ticket */
    krb5_enc_data enc_part;             /**< encryption type, kvno, encrypted encoding */
    krb5_enc_kdc_rep_part *enc_part2;   /**< unencrypted version, if available */
} krb5_kdc_rep;

/** @brief error message structure */
typedef struct _krb5_error {
    krb5_magic magic;
    /* some of these may be meaningless in certain contexts */
    krb5_timestamp ctime;               /**< client sec portion; optional */
    krb5_int32 cusec;                   /**< client usec portion; optional */
    krb5_int32 susec;                   /**< server usec portion */
    krb5_timestamp stime;               /**< server sec portion */
    krb5_ui_4 error;                    /**< error code (protocol error #'s) */
    krb5_principal client;              /**< client's principal identifier; optional */
    krb5_principal server;              /**< server's principal identifier */
    krb5_data text;                     /**< descriptive text */
    krb5_data e_data;                   /**< additional error-describing data */
} krb5_error;

/** @brief Authentication header. */

typedef struct _krb5_ap_req {
    krb5_magic magic;
    krb5_flags ap_options;              /**< requested options */
    krb5_ticket *ticket;                /**< ticket */
    krb5_enc_data authenticator;        /**< authenticator (already encrypted) */
} krb5_ap_req;

/**
 * @brief C representaton of AP-REP message.
 * The server's response to a client's request for mutual authentication.
 *
 */

typedef struct _krb5_ap_rep {
    krb5_magic magic;
    krb5_enc_data enc_part;             /**< Ciphertext of ApRepEncPart */
} krb5_ap_rep;

/** @brief Cleartext that is encrypted and put into @c _krb5_ap_rep.  */
typedef struct _krb5_ap_rep_enc_part {
    krb5_magic magic;
    krb5_timestamp ctime;               /**< client time, seconds portion */
    krb5_int32 cusec;                   /**< client time, microseconds portion */
    krb5_keyblock *subkey;              /**< true session key, optional */
    krb5_ui_4 seq_number;               /**< sequence #, optional */
} krb5_ap_rep_enc_part;

/** @brief Unused.  */
typedef struct _krb5_response {
    krb5_magic magic;
    krb5_octet message_type;
    krb5_data response;
    krb5_int32 expected_nonce;  /**< The expected nonce for KDC_REP messages */
    krb5_timestamp request_time;   /**< When we made the request */
} krb5_response;

/**
 * @brief Credentials information inserted into @c EncKrbCredPart.
 *
 * @sa tktflag
 */

typedef struct _krb5_cred_info {
    krb5_magic magic;
    krb5_keyblock *session;             /**< session key used to encrypt ticket */
    krb5_principal client;              /**< client name/realm, optional */
    krb5_principal server;              /**< server name/realm, optional */
    krb5_flags flags;                   /**< ticket flags, optional */
    krb5_ticket_times times;            /**< auth, start, end, renew_till, optional */
    krb5_address **caddrs;              /**< array of ptrs to addresses */
} krb5_cred_info;

/**  @brief Cleartext credentials information.  */
typedef struct _krb5_cred_enc_part {
    krb5_magic magic;
    krb5_int32 nonce;                   /**< nonce, optional */
    krb5_timestamp timestamp;           /**< client time */
    krb5_int32 usec;                    /**< microsecond portion of time */
    krb5_address *s_address;    /**< sender address, optional */
    krb5_address *r_address;    /**< recipient address, optional */
    krb5_cred_info **ticket_info;
} krb5_cred_enc_part;

/**  @brief Credentials data structure.*/
typedef struct _krb5_cred {
    krb5_magic magic;
    krb5_ticket **tickets;              /**< tickets */
    krb5_enc_data enc_part;             /**< encrypted part */
    krb5_cred_enc_part *enc_part2;      /**< unencrypted version, if available*/
} krb5_cred;

/** @brief Sandia password generation structure */
typedef struct _passwd_phrase_element {
    krb5_magic magic;
    krb5_data *passwd;
    krb5_data *phrase;
} passwd_phrase_element;

/** @brief Password data.*/
typedef struct _krb5_pwd_data {
    krb5_magic magic;
    int sequence_count;
    passwd_phrase_element **element;
} krb5_pwd_data;

/* these need to be here so the typedefs are available for the prototypes */
/*
 * Note for Windows 2000 compatibility this is encoded
 * in the enc_padata field of the krb5_enc_kdc_rep_part.
 */
typedef struct _krb5_pa_svr_referral_data {
    /** Referred name, only realm is required */
    krb5_principal     principal;
} krb5_pa_svr_referral_data;

typedef struct _krb5_pa_server_referral_data {
    krb5_data          *referred_realm;
    krb5_principal     true_principal_name;
    krb5_principal     requested_principal_name;
    krb5_timestamp     referral_valid_until;
    krb5_checksum      rep_cksum;
} krb5_pa_server_referral_data;

typedef struct _krb5_pa_pac_req {
    /** TRUE if a PAC should be included in TGS-REP */
    krb5_boolean       include_pac;
} krb5_pa_pac_req;

/*
 * begin "safepriv.h"
 */

#define KRB5_AUTH_CONTEXT_DO_TIME       0x00000001
#define KRB5_AUTH_CONTEXT_RET_TIME      0x00000002
#define KRB5_AUTH_CONTEXT_DO_SEQUENCE   0x00000004
#define KRB5_AUTH_CONTEXT_RET_SEQUENCE  0x00000008
#define KRB5_AUTH_CONTEXT_PERMIT_ALL    0x00000010
#define KRB5_AUTH_CONTEXT_USE_SUBKEY    0x00000020

/** @brief Sequence number and timestamp information output by krb5_read_priv() and krb5_read_safe().*/
typedef struct krb5_replay_data {
    krb5_timestamp      timestamp;   /**< Timestamp, seconds portion */
    krb5_int32          usec;        /**< Timestamp, microseconds portion */
    krb5_ui_4           seq;         /**< Sequence number  */
} krb5_replay_data;

/* flags for krb5_auth_con_genaddrs() */
#define KRB5_AUTH_CONTEXT_GENERATE_LOCAL_ADDR           0x00000001
#define KRB5_AUTH_CONTEXT_GENERATE_REMOTE_ADDR          0x00000002
#define KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR      0x00000004
#define KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR     0x00000008

/* type of function used as a callback to generate checksum data for
 * mk_req */

typedef krb5_error_code
(KRB5_CALLCONV * krb5_mk_req_checksum_func) (krb5_context, krb5_auth_context , void *,
                                             krb5_data **);

/*
 * end "safepriv.h"
 */


/*
 * begin "ccache.h"
 */

typedef krb5_pointer    krb5_cc_cursor; /* cursor for sequential lookup */

struct _krb5_ccache;
typedef struct _krb5_ccache *krb5_ccache;
struct _krb5_cc_ops;
typedef struct _krb5_cc_ops krb5_cc_ops;

/**
 * @brief Cursor for iterating over all ccaches
 */
struct _krb5_cccol_cursor;
typedef struct _krb5_cccol_cursor *krb5_cccol_cursor;

/* for retrieve_cred */
#define KRB5_TC_MATCH_TIMES             0x00000001
#define KRB5_TC_MATCH_IS_SKEY           0x00000002
#define KRB5_TC_MATCH_FLAGS             0x00000004
#define KRB5_TC_MATCH_TIMES_EXACT       0x00000008
#define KRB5_TC_MATCH_FLAGS_EXACT       0x00000010
#define KRB5_TC_MATCH_AUTHDATA          0x00000020
#define KRB5_TC_MATCH_SRV_NAMEONLY      0x00000040
#define KRB5_TC_MATCH_2ND_TKT           0x00000080
#define KRB5_TC_MATCH_KTYPE             0x00000100
#define KRB5_TC_SUPPORTED_KTYPES        0x00000200

/* for set_flags and other functions */
#define KRB5_TC_OPENCLOSE               0x00000001
#define KRB5_TC_NOTICKET                0x00000002

/**
 * @brief Retrieve the name but not type of a credential cache.
 *
 * @param context           Context structure [input, output]
 * @param cache            Credentials cache handle [input]
 *
 * Returns the name of the credential cache as an alias that should not be
 * freed or modified by the caller.  This name does not include the type
 * portion, so cannot be used as input to krb5_cc_resolve().
 * Make sure to free the allocated memory when it is no longer needed.
 */
const char * KRB5_CALLCONV
krb5_cc_get_name(krb5_context context, krb5_ccache cache);

/**
 * @brief Generate a new handle for a specified (unopened) credentials cache.
 *
 * @param context           Context structure [input, output]
 * @param cache             Credentials cache handle [input, output]
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_gen_new(krb5_context context, krb5_ccache *cache);

/**
 * @brief Destroy an existing credentials cache and create a new credentials cache by the same name.
 *
 * @param context                      Context structure [input, output]
 * @param cache                       Credentials cache handle [input, output]
 * @param principal                    Primary principal name for the credentials cache [output]
 *
 * Destroy an existing credentials cache and create a new credentials cache by the same name,
 * as specifed by @a cache for specified principal.
 *
 * @note This function also modifies the specified credentials cache.
 *
 * @retval
 *  0  Success
 * @return
 *  System errors
 * @return
 *  Permission errors
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_initialize(krb5_context context, krb5_ccache cache,
                   krb5_principal principal);

/**
 * @brief Destroy a credentials cache.
 *
 * @param context           Context structure [input, output]
 * @param cache            Credentials cache handle [input]
 *
 * This function invalidates @a cache and releases any other resources
 * acquired during use of the credentials cache. @a cache must identify a valid credentials cache.
 *
 * @note After completion, do not use @a cache until it is reinitialized with krb5_cc_resolve() or krb5_cc_gen_new().
 *
 * @retval
 *  0  Success
 * @return
 *  Permission errors
 *
 * @sa krb5_cc_gen_new()
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_destroy(krb5_context context, krb5_ccache cache);

/**
 * @brief  Close a credentials cache and invalidate its handle.
 *
 * @param context                Context structure [input, output]
 * @param cache                  Credentials cache handle [input, output]
 *
 * @note Reinitialize @a cache with krb5_cc_resolve() or  krb5_cc_gen_new().
 *
 * @retval
 *  0    Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_close(krb5_context context, krb5_ccache cache);

/**
 * @brief Store credentials in a specified credentials cache.
 *
 * @param context            Context structure [input, output]
 * @param cache             Credentials cache handle [input]
 * @param creds              Credentials to be stored in cache [input]
 *
 * @retval
 *  0  Success
 * @return
 *  Permission errors
 * @return
 *  Storage failure errors
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_store_cred(krb5_context context, krb5_ccache cache, krb5_creds *creds);

/**
 * @brief Search a credentials cache for credentials matching @a mcreds and return it if found.
 *
 * @param context            Context structure [input, output]
 * @param cache              Credentials cache handle [input]
 * @param mcreds             Credentials to match [input]
 * @param creds              Credentials that match the requested value [output]
 * @param flags            Search flags; values should be bitwise ORed together [input]
 *
 * Valid values for @a options are:
 *
 * @li @c KRB5_TC_MATCH_TIMES          The requested lifetime must be at least as great as that specified.
 * @li @c KRB5_TC_MATCH_IS_SKEY        The @a is_skey field much match exactly.
 * @li @c KRB5_TC_MATCH_FLAGS          The set bits in @a mcreds must match in @a creds.
 * @li @c KRB5_TC_MATCH_TIMES_EXACT    The requested lifetime must match exactly.
 * @li @c KRB5_TC_MATCH_FLAGS_EXACT     All bits in @a mcreds must match exactly.
 * @li @c KRB5_TC_MATCH_AUTHDATA       The  data must match.
 * @li @c KRB5_TC_MATCH_SRV_NAMEONLY    Only the name portion of the principal name must match.
 *
 * The realm field can be different. If this flag is not set, the entire principal name must match.
 * Valid values are:
 *
 * @li @c KRB5_TC_MATCH_2ND_TKT      The second tickets must match.
 * @li @c KRB5_TC_MATCH_KTYPE        The encryption key types must match.
 * @li @c KRB5_TC_MATCH_SUPPORTED_KTYPES   Check all matching entries that have any supported
 *                                         encryption type and return the one with the encryption
 *                                         type listed earliest.
 * @retval
 *  0  Success
 * @return
 *  Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_retrieve_cred(krb5_context context, krb5_ccache cache,
                      krb5_flags flags, krb5_creds *mcreds,
                      krb5_creds *creds);

/**
 * @brief Get the primary principal of a credentials cache.
 *
 * @param context            Context structure [input, output]
 * @param cache              Credentials cache handle  [input]
 * @param principal          Primary principal [output]
 *
 * @note The primary principal is set by calling  krb5_cc_initialize().
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_get_principal(krb5_context context, krb5_ccache cache,
                      krb5_principal *principal);

/**
 * @brief Prepare to sequentially read every credential in a credentials cache.
 *
 * @param context           Context structure [input, output]
 * @param cache             Credentials cache handle [input]
 * @param cursor            Cursor [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_start_seq_get(krb5_context context, krb5_ccache cache,
                      krb5_cc_cursor *cursor);

/**
 * @brief Retrieve the next entry from the credentials cache.
 *
 * @param context           Context structure [input, output]
 * @param cache             Credentials cache handle
 * @param cursor            Cursor  [input, output]
 * @param creds             Credentials cache entry corresponding to the cursor [output]
 *
 * @note The cursor value is updated when the function returns the credentials cache entry.
 * Subsequent calls to krb5_cc_next_cred() use the updated value.
 *
 * @sa krb5_end_seq_get()
 *
 * @retval
 * 0 Success
 * @return
 * Error if there are no more cache entries
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_next_cred(krb5_context context, krb5_ccache cache,
                  krb5_cc_cursor *cursor, krb5_creds *creds);

/**
 * @brief Finish processing credentials cache entries and invalidate @a cursor.
 *
 * @param context           Context structure [input, output]
 * @param cache             Credentials cache handle [input, output]
 * @param cursor            Cursor [input]
 *
 * @note  Use krb5_cc_start_seq_get() to create a new @a cursor for the next sequential read operation.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Error if @a cursor is invalid
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_end_seq_get(krb5_context context, krb5_ccache cache,
                    krb5_cc_cursor *cursor);

/**
 * @brief Remove credentials from a credentials cache.
 *
 * @param context               Context structure [input, output]
 * @param cache                 Credentials cache handle [input]
 * @param flags                 Search flags [input]
 * @param creds                 Credentials to be matched [input]
 *
 * Remove any credentials that match the principal name (@a cred->server) and the fields
 * in the credentials cache masked by @a which.
 *
 *  Valid values for search flags are:
 * @li @c KRB5_TC_MATCH_TIMES         The requested lifetime is required to be at least as great as that specified.
 * @li @c KRB5_TC_MATCH_IS_SKEY       The @a is_skey field much match exactly.
 * @li @c KRB5_TC_MATCH_FLAGS         The set bits in @a mcreds must match in @a creds.
 * @li @c KRB5_TC_MATCH_TIMES_EXACT   The requested lifetime must match exactly.
 * @li @c KRB5_TC_MATCH_FLAGS_EXACT   All bits in @a mcreds must match exactly.
 * @li @c KRB5_TC_MATCH_AUTHDATA      The authentication data must match.
 * @li @c KRB5_TC_MATCH_SRV_NAMEONLY   Only the name portion of the principal name must match.
 *
 * The realm field can be different. By default, the entire principal name must match.
 *
 * @li @c KRB5_TC_MATCH_2ND_TKT        The second tickets must match.
 * @li @c KRB5_TC_MATCH_KTYPE          The encryption key types must match.
 * @li @c KRB5_TC_MATCH_SUPPORTED_KTYPES   Check all matching entries that have any supported encryption type.
 *
 * @note The values for @a flags should be bitwise-ORed together.
 *
 * @return
 *  No matches found
 * @return
 *  Data cannot be deleted
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_remove_cred(krb5_context context, krb5_ccache cache, krb5_flags flags,
                    krb5_creds *creds);

/**
 * @brief Set options flags on a credentials cache.
 *
 * @param context           Context structure [input, output]
 * @param cache             Credentials cache handle [input, output
 * @param flags           Set behavior for opening and closing a @a cache.
 *
 * Set @a options to zero to clear a previously set @c KRB5_TC_OPENCLOSE flag.
 *
 * @note Turning on @c OPENCLOSE mode opens and closes the @a cache each time a credentials
 * cache routine is called. If this flag is not set, the @a cache stays open until  krb5_cc_close() is called.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_set_flags(krb5_context context, krb5_ccache cache, krb5_flags flags);

/**
 * @brief Get @a flags from a credentials cache.
 *
 * @param context           Context structure [input, output]
 * @param cache            Credentials cache handle [input]
 * @param flags             A bit mask representing the flags to get [input]
 *
 * @todo what kind of flags?? link to list
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_get_flags(krb5_context context, krb5_ccache cache, krb5_flags *flags);

/**
 * @brief Retrieve the type of a credential cache.
 *
 * @param context           Context structure [input, output]
 * @param cache             Credentials cache handle [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @return The type of a credential cache as an alias that should not be
 * modified or freed by the caller.
 */
const char * KRB5_CALLCONV
krb5_cc_get_type(krb5_context context, krb5_ccache cache);

krb5_error_code KRB5_CALLCONV
krb5_cc_move(krb5_context context, krb5_ccache src, krb5_ccache dst);

krb5_error_code KRB5_CALLCONV
krb5_cc_last_change_time(krb5_context context, krb5_ccache ccache,
                         krb5_timestamp *change_time);

krb5_error_code KRB5_CALLCONV
krb5_cc_lock(krb5_context context, krb5_ccache ccache);

krb5_error_code KRB5_CALLCONV
krb5_cc_unlock(krb5_context context, krb5_ccache ccache);

/**
 * @brief Prepare to iterate over a collection of credentials caches.
 *
 * @param context           Context structure [input, output]
 * @param cursor            Cursor [input, output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cccol_cursor_new(krb5_context context, krb5_cccol_cursor *cursor);

/**
 * @brief Get the next credentials cache in the collection.
 *
 * @param context           Context structure [input, output]
 * @param cursor            Cursor [input, output]
 * @param ccache            Credentials cache handle [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cccol_cursor_next(krb5_context context, krb5_cccol_cursor cursor,
                       krb5_ccache *ccache);

/**
 * @brief Free a credentials cache collection cursor.
 *
 * @param context           Context structure [input, output]
 * @param cursor            Cursor [input]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cccol_cursor_free(krb5_context context, krb5_cccol_cursor *cursor);

krb5_error_code KRB5_CALLCONV
krb5_cccol_last_change_time(krb5_context context, krb5_timestamp *change_time);

krb5_error_code KRB5_CALLCONV
krb5_cccol_lock(krb5_context context);

krb5_error_code KRB5_CALLCONV
krb5_cccol_unlock(krb5_context context);

/**
 * @brief Create a new unique credentials cache of the specified type.
 *
 * @param context           Context structure [input, output]
 * @param type              Credentials cache type [input, output]
 * @param hint              Unused
 * @param id                Credentials cache handle [output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_new_unique(krb5_context context, const char *type, const char *hint,
                   krb5_ccache *id);

/*
 * end "ccache.h"
 */

/*
 * begin "rcache.h"
 */

struct krb5_rc_st;
typedef struct krb5_rc_st *krb5_rcache;

/*
 * end "rcache.h"
 */

/*
 * begin "keytab.h"
 */


/* XXX */
#define MAX_KEYTAB_NAME_LEN 1100 /* Long enough for MAXPATHLEN + some extra */

typedef krb5_pointer krb5_kt_cursor;    /* XXX */

/**  @brief Key table entry. */
typedef struct krb5_keytab_entry_st {
    krb5_magic magic;
    krb5_principal principal;   /**< principal of this key */
    krb5_timestamp timestamp;   /**< time entry written to keytable */
    krb5_kvno vno;              /**< key version number */
    krb5_keyblock key;          /**< the secret key */
} krb5_keytab_entry;

struct _krb5_kt;
typedef struct _krb5_kt *krb5_keytab;

/**
 * @brief Return the key table prefix string.
 *
 * @param context           Context structure [input, output]
 * @param keytab            Type of key table structure to be returned [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 */
const char * KRB5_CALLCONV
krb5_kt_get_type(krb5_context context, krb5_keytab keytab);

/**
 * @brief  Zeroes @a name and copies the key table name (including its prefix).
 *
 * @param context           Context structure. [input/output]
 * @param keytab            Key table handle [input/out]
 * @param name              Key table name [input]
 * @param namelen           Maximum length to fill in name [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @retval
 * KRB5_KT_NAME_TOOLONG  Key table name does not fit in @a namelen bytes
 *
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_get_name(krb5_context context, krb5_keytab keytab, char *name,
                 unsigned int namelen);

/**
 * @brief Close a key table, invalidate its handle, and release any other resources acquired during use of the key table.
 *
 * @param context           Context structure [input, output]
 * @param keytab            Key tablele handle [input, output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 * @sa enctype
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_close(krb5_context context, krb5_keytab keytab);

/**
 * @brief Retrieve an entry from a key table that matches the @a keytab, @a principal, and @a vno.
 *
 * @param context       Context structure [input, output]
 * @param keytab        Key table handle [input, output]
 * @param principal     Principal name [input]
 * @param vno           Key version number [input]
 * @param enctype       Encryption type [input]
 * @param entry         Returned entry from key tablele [output]
 *
 * @note If @a vno is zero, the function retrieves the first entry that
 * matches the specified principal.
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_get_entry(krb5_context context, krb5_keytab keytab,
                  krb5_const_principal principal, krb5_kvno vno,
                  krb5_enctype enctype, krb5_keytab_entry *entry);

/**
 * @brief Start a sequential retrieve of key table entries.
 *
 * @param context           Context structure [input, output]
 * @param keytab            Key table handle [input, output ]
 * @param cursor            Cursor [output]
 *
 * Prepare to read sequentially every key in the specified key table.
 * @a cursor is incremented for next call to krb5_kt_next_entry().
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_start_seq_get(krb5_context context, krb5_keytab keytab,
                      krb5_kt_cursor *cursor);

/**
 * @brief Retrieve the next entry from the key table.
 *
 * @param context           Context structure [input, output]
 * @param keytab            Key table handle [input, output]
 * @param entry             Returned key table entry [output]
 * @param cursor            Cursor (output]

 * Return the next sequential entry in the specified key table and update @a cursor for
 * the next request.
 *
 * If the key table changes during the sequential get, an error is guaranteed.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_next_entry(krb5_context context, krb5_keytab keytab,
                   krb5_keytab_entry *entry, krb5_kt_cursor *cursor);

/**
 * @brief Complete a series of sequential key table entry retrievals and invalidate @a cursor.
 *
 * @param context           Context structure [input, output]
 * @param keytab            Key table handle [input, output]
 * @param cursor            Cursor [output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_end_seq_get(krb5_context context, krb5_keytab keytab,
                    krb5_kt_cursor *cursor);

/*
 * end "keytab.h"
 */

/*
 * begin "func-proto.h"
 */

/**
 * @brief Intialize a context structure.
 *
 * @param context           Context structure [input, output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */

krb5_error_code KRB5_CALLCONV
krb5_init_context(krb5_context *context);

/**
 * @brief Initialize a context structure, using only configuration files that are safe for a @c setuid program.
 *
 * @param context           Context structure [input, output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_init_secure_context(krb5_context *context);

/**
 * @brief Free a context structure.
 *
 * @param context           Context structure [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_context(krb5_context context);

/**
 * @brief Copy a @c _krb5_context structure.
 *
 * @param ctx           Context structure [input, output]
 * @param nctx_out
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_context(krb5_context ctx, krb5_context *nctx_out);

/**
 * @brief Set the default TGS (ticket granting service) encryption types for the context.
 *
 * @param context              Context structure [input, output]
 * @param etypes               Encryption type [input]
 *
 * @note This overrides the default list (from config file or built-in).
 *
 * @retval
 *  0    Success
 * @retval
 *  ENOMEM Insufficient memory
 * @retval
 *  KRB5_PROG_ETYPE_NOSUPP Program lacks support for encryption type

 * @return
 * Kerberos error codes
 *
 * @sa enctype
 */
krb5_error_code KRB5_CALLCONV
krb5_set_default_tgs_enctypes(krb5_context context, const krb5_enctype *etypes);

/**
 * @brief Return a list of supported encryption types.
 *
 * @param context           Context structure [input, output]
 * @param ktypes            Pointer to list of encryption types [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0   Success
 * @retval
 *  ENOMEM Insufficient memory
 * @retval
 *  KRB5_PROG_ETYPE_NOSUPP Program lacks support for encryption type
 * @return
 * Kerberos error codes
 *
 * @sa enctype
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_get_permitted_enctypes(krb5_context context, krb5_enctype **ktypes);

/**
 * @brief Return a value indicating whether the client libraries support multithreading.
 *
 * @retval
 *  TRUE  Client libraries are threadsafe
 * @retval
 *  FALSE Client libraries are not threadsafe
 *
 */
krb5_boolean KRB5_CALLCONV
krb5_is_thread_safe(void);

/* libkrb.spec */

/**
 * @brief Decrypt a ticket using the specified key table.
 *
 * @param context           Context structure [input, output]
 * @param kt                Key table [input]
 * @param ticket            Ticket [input, output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_server_decrypt_ticket_keytab(krb5_context context, const krb5_keytab kt,
                                  krb5_ticket *ticket);

/**
 * @brief Free credentials returned by krb5_get_cred().
 *
 * @param context           Context structure [input, output]
 * @param tgts              Pointer to credentials to be freed [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_tgt_creds(krb5_context context, krb5_creds **tgts);

#define KRB5_GC_USER_USER       1       /* want user-user ticket */
#define KRB5_GC_CACHED          2       /* want cached ticket only */
#define KRB5_GC_CANONICALIZE    4       /* set canonicalize KDC option */
#define KRB5_GC_NO_STORE        8       /* do not store in credentials cache */
#define KRB5_GC_FORWARDABLE             16  /* acquire forwardable tickets */
#define KRB5_GC_NO_TRANSIT_CHECK        32  /* disable transited check */
#define KRB5_GC_CONSTRAINED_DELEGATION  64  /* constrained delegation */

/**
 * @brief Get an additional ticket.
 *
 * @param context           Context structure [input, output]
 * @param options           Options [input]
 * @param ccache            Credentials cache handle  [input]
 * @param in_creds          Input credentials  [input]
 * @param out_creds         Output updated credentials  [output]
 *
 * Valid values for @a options are:
 * @li @c KRB5_GC_USER_USER   Return a full user to user authentication ticket
 * @li @c KRB5_GC_CACHED   Search only credentials cache for the ticket
 *
 * Use the specified credentials cache or a TGS exchange to get an additional ticket and include the following information:
 * @li  The server specified by @a in_creds->server.
 * @li  The options specified in @a options.
 *
 *  If @a options is set to @c KRB5_GC_USER_USER, krb5_get_credentials() searches only the credentials cache
 *  for a ticket.
 *  If @a options is set to @c KRB5_GC_CACHED, krb5_get_credentials() will get credentials for a
 * user-to-user authentication. In a user-to-user authentication, the secret key for the server is
 * the session key from the server's ticket granting ticket (TGT).
 * @li  The expiration date specified in @a in_creds->times.endtime.
 * @li  The session key type specified in @a in_creds->keyblock.keytype, if it is nonzero.
 *
 * The TGT is passed from the server to the client over the network; this is
 * safe because the TGT is encrypted in a key known only by the Kerberos server.
 * The client must pass this TGT to krb5_get_credentials() in @a in_creds->second_ticket.
 * The Kerberos server uses this TGT to construct a user-to-user ticket that can be verified by the server,
 * using the session key from its TGT.
 *
 * The effective expiration date is the minimum of the following:
 *
 * @li The expiration date as specified in @a in_creds->times.endtime.
 * @li The requested start time plus the maximum lifetime of the server
 * as specified by the server's entry in the Kerberos database.
 * @li The requested start time plus the maximum lifetime of tickets allowed
 * in the local site, as specified by the KDC. This is a compile-time option,
 * @c KRB5_KDB_MAX_LIFE in @c config.h, and its default value is one day.
 *
 * If any special  data needs to be included in the ticket (such as restrictions
 * on how the ticket can be used), specify it in @a in_creds->authdata.
 * If there is no special  data to be passed, set @a in_creds->authdata to NULL.
 *  Any returned ticket and intermediate ticket-granting tickets are stored in @a ccache.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @todo ers clean up verb tense and format
 *
 * @retval
 *  0  Success
 * @retval
 *  ENOMEM  Insufficient memory
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_get_credentials(krb5_context context, krb5_flags options,
                     krb5_ccache ccache, krb5_creds *in_creds,
                     krb5_creds **out_creds);

/**
 * @brief Contact the KDC to validate a credential.
 *
 * @param context             Context structure [input, output]
 * @param options             Unused
 * @param ccache              Credentials cache handle [input, output]
 * @param in_creds            Input credentials [input]
 * @param out_creds           Output credentials [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @retval
 *  0  Success
 * @retval
 *  ENOMEM Insufficient memory
 * @retval
 *  KRB5_PROG_ETYPE_NOSUPP Encryption type is not supported
 * @retval
 *  KRB5_KDCREP_MODIFIED KDC reply did not match expectations
 * @return
 *  Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_get_credentials_validate(krb5_context context, krb5_flags options,
                              krb5_ccache ccache, krb5_creds *in_creds,
                              krb5_creds **out_creds);

/**
 * @brief Contact the KDC to renew credentials for a context.
 *
 * @param context           Context structure [input, output]
 * @param options           Unused
 * @param ccache            Credentials cache handle [input, output]
 * @param in_creds          Input credentials [input]
 * @param out_creds         Output credentials [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0  Success
 * @retval
 *  ENOMEM Insufficient memory
 * @retval
 *  KRB5_PROG_ETYPE_NOSUPP Encryption type is not supported
 * @retval
 *  KRB5_KDCREP_MODIFIED KDC reply did not match expectations
 * @return
 *  Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_get_credentials_renew(krb5_context context, krb5_flags options,
                           krb5_ccache ccache, krb5_creds *in_creds,
                           krb5_creds **out_creds);

/**
 * @brief Format a @c KRB_AP_REQ message.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context, containing the checksum method to be used; a new authentication contextis returned if NULL is specified. [input, output]
 * @param in_data           Application data with a checksum to be included in the authenticator; specify NULL if no checksum is to be included [input]
 * @param   ap_req_options
 * @param   service
 * @param   hostname
 * @param   ccache
 * @param outbuf             Pointer to an existing @c krb5_data structure to be filled [output]
 *
 * The @a in_creds argument supplies the credentials (ticket and session key) needed to form the request.
 *
 * If @a in_creds->ticket has no data (length == 0), an error is returned.
 *
 * A copy of the authenticator is stored in @c _krb5_auth_context, with the
 * @a principal and @a checksum fields nulled out, unless an error is returned.
 * (This is to prevent pointer-sharing problems)
 *
 * @note @a in_creds might be freed and reallocated. Make sure all structure fields' pointers point to allocated memory,
 *
 * @warning Do not alias other pointers to the same memory, since it can be deallocated during this routine call.
 *
 * @return
 * Generated @c AP-REQ message
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_mk_req(krb5_context context, krb5_auth_context *auth_context,
            krb5_flags ap_req_options, char *service, char *hostname,
            krb5_data *in_data, krb5_ccache ccache, krb5_data *outbuf);

/**
 * @brief Format a @c KRB_AP_REQ message with additional options.
 *
 * @param context            Context structure
 * @param auth_context       Authentication context, containing the checksum method to be used; a new authentication context is returned if NULL is specified. [input, output]
 * @param ap_req_options     @c KRB_AP_REQ options desired [input]
 * @param in_data             Application data with a checksum that should be included in the authenticator; specify NULL if no checksum is to be included [input]
 * @param in_creds            Credentials for the service [input]
 * @param outbuf              Pointer to an existing @c krb5_data structure to be filled [output]
 *
 * Valid values for @a ap_req_options are:
 * @li @c AP_OPTS_USE_SESSION_KEY
 * @li @c AP_OPTS_MUTUAL_REQUIRED
 *
 * The @a outbuf, @a ap_req_options, _krb5_auth_context, and @a ccache arguments are used
 * in the same fashion as for krb5_mk_req(). The @a in_creds argument supplies
 * the credentials (ticket and session key).
 *
 * If @a in_creds->ticket has no data (length == 0), an error is returned.
 *
 * If @a ap_req_options specifies @c AP_OPTS_USE_SUBKEY, krb5_generate_subkey() generates the subkey if needed.
 *
 *  A copy of the authenticator is stored in @c _krb5_auth_context, with the
 * @a principal and @a checksum fields nulled out, unless an error is returned.
 * (This is to prevent pointer-sharing problems; the caller should not need
 * these fields anyway, since the caller supplied them.)
 *
 * @note @a in_creds can be freed and reallocated. Make sure all structure fields pointers point to allocated memory,
 * Do not alias other pointers to the same memory, since it may be deallocated during this routine call.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @return
 * Generated @c AP-REQ message
 * @return
 * Kerberos error codes
 * @sa aptopts
 */
krb5_error_code KRB5_CALLCONV
krb5_mk_req_extended(krb5_context context, krb5_auth_context *auth_context,
                     krb5_flags ap_req_options, krb5_data *in_data,
                     krb5_creds *in_creds, krb5_data *outbuf);

/**
 * @brief Format and encrypt a @c KRB5_AP_REP message.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [input, output]
 * @param outbuf            @c AP-REP message information [output]
 *
 * The @c AP-REP message includes the data in the @a authentp field of @c _krb5_auth_context,
 * and it is encrypted using the @a keyblock field from @c _krb5_auth_context.
 *
 * When successful, @a outbuf->length and @a outbuf->data are filled in with the length
 * of the @c AP-REQ message and the allocated data holding it.
 *
 * If the flags in @c _krb5_auth_context indicate that a sequence number should be used
 * (either @c KRB5_AUTH_CONTEXT_DO_SEQUENCE or @c KRB5_AUTH_CONTEXT_RET_SEQUENCE)
 * and the local sequence number in @c _krb5_auth_context is 0, a new number will
 * be generated with krb5_generate_seq_number().
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_mk_rep(krb5_context context, krb5_auth_context auth_context, krb5_data *outbuf);

krb5_error_code KRB5_CALLCONV
krb5_mk_rep_dce(krb5_context context, krb5_auth_context auth_context, krb5_data *outbuf);

/**
 * @brief Parse and decrypt a @c KRB5_AP_REP message.
 *
 * @param context            Context structure [input, output]
 * @param auth_context       Authentication context [input, output]
 * @param inbuf              AP-REP message [input]
 * @param repl               Parsed message [output]
 *
 * The keyblock stored in @c _krb5_auth_context is used to decrypt the message
 * after establishing any key preprocessing with krb5_process_key().
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_rd_rep(krb5_context context, krb5_auth_context auth_context,
            const krb5_data *inbuf, krb5_ap_rep_enc_part **repl);

krb5_error_code KRB5_CALLCONV
krb5_rd_rep_dce(krb5_context context, krb5_auth_context auth_context,
                const krb5_data *inbuf, krb5_ui_4 *nonce);

/**
 * @brief Encode a @c KRB5_ERROR message.
 *
 * @param context           Context structure [input, output]
 * @param dec_err           Error structure to be encoded [input]
 * @param enc_err           Encoded error structure [output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_mk_error(krb5_context context, const krb5_error *dec_err,
              krb5_data *enc_err);

/**
 * @brief Decode a @c KRB-ERROR message.
 *
 * @param context           Context structure [input, output]
 * @param enc_errbuf        Encoded error message [input]
 * @param dec_error         Decoded error message [output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_rd_error(krb5_context context, const krb5_data *enc_errbuf,
              krb5_error **dec_error);

/**
 * @brief Parse a @c KRB-SAFE message, verify its integrity, and store its data in the specified buffer.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication structure [input, output]
 * @param inbuf             @c KRB-SAFE message to be parsed [input]
 * @param outbuf            Data parsed from @c KRB-SAFE message [output]
 * @param outdata           Sequence numbers if @c krb5_auth_context includes @c KRB5_AUTHCONTEXT_RET_SEQUENCE [input, output]
 *
 * The keyblock used to verify the integrity of the message is taken from the fields
 * @a local_subkey, @a remote_subkey, or @a keyblock in @c _krb5_auth_context. The @a keyblock
 * is chosen in the preceding order by the first one that is non-null.
 *
 * @a remote_addr and @a localaddr in @c _krb5_auth_context specify
 * the full addresses (host and port) of the sender and receiver, and must be of
 * type @c ADDRTYPE_ADDRPORT.
 *
 * The @a remote_addr argument is @a mandatory.  It specifies the address of the sender.
 * If the address of the sender in the message does not match @a remote_addr, the
 * error @c KRB5KRB_AP_ERR_BADADDR will be returned.
 *
 * If @a local_addr is non-null, then the address of the receiver in the message must
 * match it. If it is NULL, the receiver address in the message will be checked against the
 * list of local addresses as returned by krb5_os_localaddr(). If the check fails,
 * @c KRB5KRB_AP_ERR_BADARRD is returned.
 *
 * If the @a flags field in @c _krb5_auth_context indicates that sequence numbers
 * are to be used (if @c KRB5_AUTH_CONTEXT_DOSEQUENCE is set in it), the @c remote_seq_number field
 * of @c _krb5_auth_context is compared to the sequence number for the message, and
 * @c KRB5_KRB_AP_ERR_BADORDER is returned if it does not match. Otherwise, the sequence
 * number is not used.
 *
 * If timestamps are to be used (if @c KRB5_AUTH_CONTEXT_DO_TIME is set in @c _krb5_auth_context),
 *  then two additional checks are performed:
 *
 * @li The timestamp in the message must be within the permitted clock skew
 * (which is usually five minutes), or @c KRB5KRB_AP_ERR_SKEW is returned.
 * @li The message must not be a replayed message, according to @a rcache.
 *
 * Make sure to free the allocated memory when it is no longer needed
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_rd_safe(krb5_context context, krb5_auth_context auth_context,
             const krb5_data *inbuf, krb5_data *outbuf,
             krb5_replay_data *outdata);

/**
 * @brief Decode and decrypt a @c KRB-PRIV message.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [input, output]
 * @param inbuf             @c KRB-PRIV message[input]
 * @param outbuf            Application data stored in @c KRB_PRIV message [output]
 * @param outdata          Sequence numbers [input, output]
 *
 * The @a remote_addr field of @c _krb5_auth_context set by krb5_auth_con_setaddrs() is
 * @a mandatory; it specifies the address of the sender. If the address of the sender in the
 * message does not match the @a remote_addr, @c KRB5KRB_AP_ERR_BADADDR is returned.
 *
 * If @c local_addr field of @c _krb5_auth_context is non-null, the address of the
 * receiver in the message must match it. If @a local_addr is NULL, the receiver address in the
 * message will be checked against the list of local addresses as returned by krb5_os_localaddr().
 *
 * The @a keyblock field of @c _krb5_auth_context specifies the key to be used to decrypt the message.
 * If the @a i_vector field is non-null, it is used as an initialization vector
 * for the decryption (if the encryption type of the message supports initialization vectors)
 * and its contents are replaced with the last block of encrypted data in the message.
 *
 * @a flags in @c _krb5_auth_context specify if timestamps (@c KRB5_AUTH_CONTEXT_DO_TIME)
 * and sequence numbers (@c KRB5_AUTH_CONTEXT_DO_SEQUENCE, @c KRB5_AUTHCONTEXT_RET_SEQUENCE) are used.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_rd_priv(krb5_context context, krb5_auth_context auth_context,
             const krb5_data *inbuf, krb5_data *outbuf,
             krb5_replay_data *outdata);

/**
 * @brief Convert a single-string representation of a principal name to multi-part principal format used in the protocols.
 *
 * @param context           Context structure [input, output]
 * @param name              Single string representation of a Kerberos principal name [input]
 * @param nprincipal        Multipart principal format used in protocols [output]
 *
 * A single-string representation of a Kerberos name consists of one
 * or more principal name components, separated by slashes, optionally followed by
 * the \@ character and a realm name. If the realm name is not specified, the local realm is used.
 *
 * To use the slash and \@ symbols as part of a component (quoted)
 * instead of using them as a component separator or as a realm prefix),
 *  put a  backslash (\) character in front of the symbol. Similarly, newline, tab, backspace, and NULL characters
 * can be included in a component by using @a n, @a t,@a b or @a 0, respectively.
 *
 * @note The realm in a Kerberos name @a cannot contain  slash, colon, or NULL characters.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @retval
 * ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_parse_name(krb5_context context, const char *name, krb5_principal *nprincipal);

#define KRB5_PRINCIPAL_PARSE_NO_REALM           0x1
#define KRB5_PRINCIPAL_PARSE_REQUIRE_REALM      0x2
#define KRB5_PRINCIPAL_PARSE_ENTERPRISE         0x4

krb5_error_code KRB5_CALLCONV
krb5_parse_name_flags(krb5_context context, const char *name,
                      int flags, krb5_principal *nprincipal);

/**
 * @brief Convert a multipart principal name to a single-string representation of the name.
 *
 * @param context           Context structure [input, output]
 * @param principal         Multipart principal format used in the protocols [input]
 * @param name              Single string representation of a Kerberos principal name [output]
 *
 * The resulting single-string representation uses the format and quoting conventions
 * described for krb5_parse_name().
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_unparse_name(krb5_context context, krb5_const_principal principal, register char **name);

/**
 * @brief Convert multiple protocol format principal names to string format.
 *
 * @param context           Context structure [input, output]
 * @param principal         Multipart principal format used in the protocols [input]
 * @param name              Single string format of principal name [output]
 * @param size              Size of unparsed name buffer [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 *
 * @sa kb5_unparse_name()
 */
krb5_error_code KRB5_CALLCONV
krb5_unparse_name_ext(krb5_context context, krb5_const_principal principal,
                      char **name, unsigned int *size);

#define KRB5_PRINCIPAL_UNPARSE_SHORT            0x1
#define KRB5_PRINCIPAL_UNPARSE_NO_REALM         0x2
#define KRB5_PRINCIPAL_UNPARSE_DISPLAY          0x4

krb5_error_code KRB5_CALLCONV
krb5_unparse_name_flags(krb5_context context, krb5_const_principal principal,
                        int flags, char **name);

krb5_error_code KRB5_CALLCONV
krb5_unparse_name_flags_ext(krb5_context context, krb5_const_principal principal,
                            int flags, char **name, unsigned int *size);

/**
 * @brief Set the realm name part of @a principal to @a realm.
 *
 * @param context           Context structure [input, output]
 * @param principal         Principal name [input]
 * @param realm             Realm name [input]
 *
 * @note This function frees the previous realm of @a principal.
 *
 * @retval
 *  0   Success
 * @retval
 *  EINVAL Invalid parameter
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_set_principal_realm(krb5_context context, krb5_principal principal,
                         const char *realm);

/**
 * @brief Search @a addrlist for a specified address.
 *
 * @param context           Context structure [input, output]
 * @param addr              Address to search for [input]
 * @param addrlist          Address list to be searched. Specify NULL if there is no address list [input]
 *
 * @retval
 *  TRUE    @a addr is listed in @a addrlist, or @c addrlist is NULL
 * @retval
 *  FALSE    @a addr is not listed in @a addrlist
 */
krb5_boolean KRB5_CALLCONV_WRONG
krb5_address_search(krb5_context context, const krb5_address *addr,
                    krb5_address *const *addrlist);

/**
 * @brief Compare two Kerberos addresses.
 *
 * @param context           Context structure [input, output]
 * @param addr1             First address to be compared [input]
 * @param addr2             Second address to be compared [input]
 *
 * @retval
 *  TRUE   The addresses are the same
 * @retval
 *  FALSE  The addresses are different
 */
krb5_boolean KRB5_CALLCONV
krb5_address_compare(krb5_context context, const krb5_address *addr1,
                     const krb5_address *addr2);

/**
 * @brief Return an ordering of the specified addresses.
 *
 * @param context           Context structure [input, output]
 * @param addr1             First address [input]
 * @param addr2             Second address [input]
 *
 * @retval
 *  0 The two addresses are the same
 * @retval
 *  \< 0 First address is less than second
 * @retval
 *  \> 0 First address is greater than second
 */
int KRB5_CALLCONV
krb5_address_order(krb5_context context, const krb5_address *addr1,
                   const krb5_address *addr2);

/**
 * @brief Compare the realms of two principals.
 *
 * @param context           Context structure [input, output]
 * @param princ1            First principal [input]
 * @param princ2            Second principal [input]
 *
 * @retval
 *  TRUE     The realms are the same
 * @retval
 *  FALSE    The realms are the different
 */
krb5_boolean KRB5_CALLCONV
krb5_realm_compare(krb5_context context, krb5_const_principal princ1,
                   krb5_const_principal princ2);

/**
 * @brief Compare two principal names.
 *
 * @param context           Context structure [input, output]
 * @param princ1            First principal name [input]
 * @param princ2            Second principal name [input]
 *
 * @retval
 *  TRUE  The principal names are the same
 * @retval
 *  FALSE The principal names are not the same
 */
krb5_boolean KRB5_CALLCONV
krb5_principal_compare(krb5_context context,
                       krb5_const_principal princ1,
                       krb5_const_principal princ2);

krb5_boolean KRB5_CALLCONV
krb5_principal_compare_any_realm(krb5_context context,
                                 krb5_const_principal princ1,
                                 krb5_const_principal princ2);

#define KRB5_PRINCIPAL_COMPARE_IGNORE_REALM  1
#define KRB5_PRINCIPAL_COMPARE_ENTERPRISE    2 /* UPNs as real principals */
#define KRB5_PRINCIPAL_COMPARE_CASEFOLD      4 /* case-insensitive */
#define KRB5_PRINCIPAL_COMPARE_UTF8          8 /* treat principals as UTF-8 */

krb5_boolean KRB5_CALLCONV
krb5_principal_compare_flags(krb5_context context,
                             krb5_const_principal princ1,
                             krb5_const_principal princ2,
                             int flags);

/**
 * @brief Initialize an empty @c _krb5_keyblock.
 *
 * @param context           Context structure [input, output]
 * @param enctype           Encryption type [input]
 * @param length            Length of keyblock [input]
 * @param out               Pointer to empty keyblock [output]
 *
 * Initialize a new keyblock and allocate storage
 * for the contents of the key, which will be freed along
 * with the keyblock when krb5_free_keyblock is called.
 * It is legal to pass in a length of 0, in which
 * case contents are left unallocated.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @note If @a length is set to 0, contents are left unallocated.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_init_keyblock(krb5_context context, krb5_enctype enctype,
                   size_t length, krb5_keyblock **out);

/**
 * @brief Copy a @c _krb5_keyblock.
 *
 * @param context           Context structure [input, output]
 * @param from               Keyblock to be copied [input]
 * @param to                 Pointer to copy of keyblock [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_keyblock(krb5_context context, const krb5_keyblock *from,
                   krb5_keyblock **to);

/**
 * @brief Copy the contents of a keyblock.
 *
 * @param context           Context structure [input, output]
 * @param from              Keyblock [input]
 * @param to                Pointer to copy of keyblock [output]
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_keyblock_contents(krb5_context context, const krb5_keyblock *from,
                            krb5_keyblock *to);

/**
 * @brief Copy a credentials structure.
 *
 * @param context           Context structure [input, output]
 * @param incred            Credentials structure to be copied [input]
 * @param outcred           Pointer to copy of credentials structure [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_creds(krb5_context context, const krb5_creds *incred, krb5_creds **outcred);

/**
 * @brief Copy a Kerberos data structure.
 *
 * @param context           Context structure [input, output]
 * @param indata            Data structure to be copied [input]
 * @param outdata           Pointer to copy of data structure [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_data(krb5_context context, const krb5_data *indata, krb5_data **outdata);

/**
 * @brief Copy a @c _krb5_principal structure.
 *
 * @param context           Context structure [input, output]
 * @param inprinc           Principal to be copied [input]
 * @param outprinc          Pointer to copy of principal [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_principal(krb5_context context, krb5_const_principal inprinc,
                    krb5_principal *outprinc);

/**
 * @brief Copy an array of addresses.
 *
 * @param context           Context structure [input, output]
 * @param inaddr            Array of addresses to be copied [input]
 * @param outaddr           Pointer to copy of array of addresses [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_addresses(krb5_context context, krb5_address *const *inaddr,
                    krb5_address ***outaddr);

/**
 * @brief Copy a krb5_ticket structure.
 *
 * @param context           Context structure [input, output]
 * @param from              Ticket structure to be copied [input]
 * @param pto               Pointer to copy of ticket structure [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_ticket(krb5_context context, const krb5_ticket *from, krb5_ticket **pto);

/**
 * @brief Copy an array of authentication data structures.
 *
 * @param context          Context structure [input, output]
 * @param in_authdat       Array of @a authdata structures [input]
 * @param out              Pointer to copy of array of @a authdata structures [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_authdata(krb5_context context,
                   krb5_authdata *const *in_authdat, krb5_authdata ***out);

/** @brief Merge two authdata arrays
 *
 * Merge two authdata arrays, such as the array from a ticket
 * and authenticator.
 */
krb5_error_code KRB5_CALLCONV
krb5_merge_authdata(krb5_context context,
                    krb5_authdata *const *inauthdat1,
                    krb5_authdata * const *inauthdat2,
                    krb5_authdata ***outauthdat);

/**
 * @brief Copy a @c _krb5_authenticator structure.
 *
 * @param context           Context structure [input, output]
 * @param authfrom          Authentication structure to be copied [input]
 * @param authto            Copy of authentication structure [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_authenticator(krb5_context context, const krb5_authenticator *authfrom,
                        krb5_authenticator **authto);

/**
 * @brief Copy a @c _krb5_checksum structure.
 *
 * @param context           Context structure [input, output]
 * @param ckfrom            Checksum to be copied [input]
 * @param ckto              Pointer to copy of checksum [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_copy_checksum(krb5_context context, const krb5_checksum *ckfrom,
                   krb5_checksum **ckto);

/**
 * @brief Open a replay cache for server use.
 *
 * @param context           Context structure [input, output]
 * @param piece             Unique identifier for replay cache [input]
 * @param rcptr             Handle to an open rcache [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_get_server_rcache(krb5_context context, const krb5_data *piece,
                       krb5_rcache *rcptr);

/**
 * @brief Build a principal name using length-counted strings.
 *
 * @param context                       Context structure [input, output]
 * @param princ                         Principal name [input]
 * @param rlen                          Realm name length [input]
 * @param realm                         Realm name [input]
 * @param ...                           List of arguments specifying length and content for each argument
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @note krb5_build_principal() and krb5_build_principal_va() perform the same task.
 * krb5_build_principal() takes variadic arguments. krb5_build_principal_va() takes a pre-computed
 * @a varargs pointer.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV_C
krb5_build_principal_ext(krb5_context context,  krb5_principal * princ,
                         unsigned int rlen, const char * realm, ...);

/**
 * @brief Build a principal name using null-terminated strings.
 *
 * @param context           Context structure [input, output]
 * @param princ              Principal name [output]
 * @param rlen              Realm name length [input]
 * @param realm             Realm name [input]
 * @param ...                 List of len1, sl1, len2, sl2...[input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @note krb5_build_principal() and krb5_build_principal_va() perform the same task.
 * krb5_build_principal() takes variadic arguments. krb5_build_principal_va() takes a pre-computed
 * @a varargs pointer.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV_C
krb5_build_principal(krb5_context context,
                     krb5_principal * princ,
                     unsigned int rlen,
                     const char * realm, ...)
#if __GNUC__ >= 4
    __attribute__ ((sentinel))
#endif
    ;
#if KRB5_DEPRECATED
/**
 * @brief Build a principal name, using a precomputed @c va_list.
 *
 * @param context           Context structure [input, output]
 * @param princ             Principal structure [output]
 * @param rlen              Realm name length [input]
 * @param realm             Realm name [input]
 * @param ...               @c va_list of arguments [input]
 *
 * @note krb5_build_principal() and krb5_build_principal_va() perform the same task.
 * krb5_build_principal() takes variadic arguments. krb5_build_principal_va() takes a pre-computed
 * @a varargs pointer.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 */
KRB5_ATTR_DEPRECATED krb5_error_code KRB5_CALLCONV
krb5_build_principal_va(krb5_context context,
                        krb5_principal princ,
                        unsigned int rlen,
                        const char *realm,
                        va_list ap);
#endif

/**
 * @brief Version of krb5_build_principal_va which allocates krb5_principal_data
 */
krb5_error_code KRB5_CALLCONV
krb5_build_principal_alloc_va(krb5_context context,
                              krb5_principal *princ,
                              unsigned int rlen,
                              const char *realm,
                              va_list ap);

/**
 * @brief Convert a Kerberos v4 principal to a Kerberos v5 principal.
 *
 * @param context           Context structure [input, output]
 * @param name              Kerberos v4 name [input]
 * @param instance          Kerberos v4 instance [input]
 * @param realm             Kerberos v4 realm [input]
 * @param princ             Kerberos v5 principal name [output]
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_425_conv_principal(krb5_context context, const char *name,
                        const char *instance, const char *realm,
                        krb5_principal *princ);

/**
 * @brief Convert a Kerberos v.5  principal to a Kerberos v.4 principal.
 *
 * @param context           Context structure [input, output]
 * @param princ             Principal [input]
 * @param name              Principal's name [output]
 * @param inst              Principal's instance name [output]
 * @param realm             Principal's realm name [output]
 *
 * @retval
 *  0  Success
 * @retval
 *  KRB5_INVALID_PRINCIPAL   Invalid principal name
 * @retval
 *  KRB5_CONFIG_CANTOPEN     Can't open or find Kerberos configuration file
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_524_conv_principal(krb5_context context, krb5_const_principal princ,
                        char *name, char *inst, char *realm);
/**
 *@deprecated
 */
struct credentials;

/**
 * @brief Convert a Kerberos v.5  principal to a Kerberos v.4 principal.
 *
 * @param context           Context structure [input, output]
 * @param v5creds           Version 5 credentials [input]
 * @param v4creds           Version 4 credentials   Principal's name [output]
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */
int KRB5_CALLCONV
krb5_524_convert_creds(krb5_context context, krb5_creds *v5creds,
                       struct credentials *v4creds);

#if KRB5_DEPRECATED
#define krb524_convert_creds_kdc krb5_524_convert_creds
#define krb524_init_ets(x) (0)
#endif

/* libkt.spec */
/**
 * @brief Get a handle for a key table.
 *
 * @param context           Context structure [input, output]
 * @param name              Name of the key table [input]
 * @param ktid              Key table handle [output]
 *
 * Fill in a handle identifying the key table with the name @a string_name.
 * The key table is not opened.
 * @note @a string_name must be of the form @c type:residual and @a type must be a type known to
 * the library.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_resolve(krb5_context context, const char *name, krb5_keytab *ktid);

/**
 * @brief Get default key table name.
 *
 * @param context           Context structure [input, output]
 * @param name              Key table name to be resolved [input, output]
 * @param name_size         Size of @a name to return [input]
 *
 * Fill @a name with the first @a name_size bytes of the name of the default key table.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @retval
 * KRB5_CONFIG_NOTENUFSPACE Buffer is too short
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_default_name(krb5_context context, char *name, int name_size);

/**
 * @brief Fill @a keytab with the default key table's @a handle.
 *
 * @param context           Context structure [input, output]
 * @param id                Key table handle [input, output]
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_default(krb5_context context, krb5_keytab *id);

/**
 * @brief Free the contents of a key table entry.
 *
 * @param context           Context structure [input, output]
 * @param entry             Key table entry whose contents are to be freed [input, output]
 *
 * @note The pointer is not freed.
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_free_keytab_entry_contents (krb5_context context, krb5_keytab_entry *entry);

/**
 * @warning  Use krb5_free_keytab_entry_contents instead; this does the same thing but is
 * misnamed and retained for backward compatability.
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_free_entry(krb5_context context, krb5_keytab_entry *entry);


/* remove and add are functions, so that they can return NOWRITE
   if not a writable keytab */

/**
 * @brief Remove an entry from a key table.
 *
 * @param context           Context structure [input, output]
 * @param id                Key table handle [input]
 * @param entry             Entry to remove from key table [input]
 *
 * @retval
 *  0 Success
 * @retval
 *  KRB5_KT_NOWRITE     Key table is not writable
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_remove_entry(krb5_context context, krb5_keytab id, krb5_keytab_entry *entry);

/**
 * @brief Add a new entry to a key table.
 *
 * @param context           Context structure [input, output]
 * @param id                Key table handle [input]
 * @param entry             Entry to be added [input]
 *
 * @retval
 * 0  Success
 * @retval
 *  ENOMEM    Insufficient memory
 * @retval
 *  KRB5_KT_NOWRITE  Key table is not writeable
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_add_entry(krb5_context context, krb5_keytab id, krb5_keytab_entry *entry);

/**
 * @brief Convert a principal name into the default salt for that principal.
 *
 * @param context           Context structure [input, output]
 * @param pr                Principal name [input]
 * @param ret               Pointer to the default salt for given principal [output]
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV_WRONG
krb5_principal2salt(krb5_context context,
                    register krb5_const_principal pr, krb5_data *ret);
/* librc.spec--see rcache.h */

/* libcc.spec */

/**
 * @brief Resolve a credentials cache name.
 *
 * @param context          Context structure [input, output]
 * @param name             Credentials cache name to be resolved [input]
 * @param cache            Credentials cache handle [output]
 *
 * Fills in @a ccache with a @a cache handle that corresponds to the name in @a name.
 * @a name must be of the form @c type=residual and @a type must be a type known to the library.
 *
 * @li Typically, the type specifier prefix is followed by a colon, not an equal sign.
 * @li When necessary to accommodate file naming differences in @a OpenVMS, the type specifier prefix can be followed by an equal sign, not a colon.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_resolve(krb5_context context, const char *name, krb5_ccache *cache);

/**
 * Create a new handle referring to the same cache as @a in.
 * The new handle and @a in can be closed independently.
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_dup(krb5_context context, krb5_ccache in, krb5_ccache *out);

/**
 * @brief Return the name of the default credentials cache.
 *
 * @param context       Context structure [input, output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @return
 * Name of default credentials cache
 */
const char *KRB5_CALLCONV
krb5_cc_default_name(krb5_context context);

/**
 * @brief Set the default credentials cache name.
 *
 * @param context           Context structure [input, output]
 * @param name              Default credentials cache name  [input, output]
 *
 * Passing a null pointer for @a name reverts the default credentials cache name to the system default.
 *
 * @note For OpenVMS only:
 * If a default name is not passed in the argument @a name, the default name is the
 * first valid entry of the following values:
 * @li @c KRB5CCNAME logical name
 * @li  the file @c krb5cc_\<PID\> in a [@c .TMP] directory in the user's login directory
 * (where \<@c PID\> is the user's process ID).
 *
 * @note The @a KRB5CCNAME logical name cannot be defined as a system-wide logical name.
 *
 * @retval
 *  0  Success
 * @retval
 *  KV5M_CONTEXT          Bad magic number for @c _krb5_context structure
 * @retval
 *  ENOMEM                Insufficient memory
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_set_default_name(krb5_context context, const char *name);

/**
 * @brief Resolve the default crendentials cache name.
 *
 * @param context           Context structure [input, output]
 * @param ccache            Pointer to credentials cache name [output]
 *
 * @retval
 * 0  Success
 * @retval
 * KV5M_CONTEXT      Bad magic number for @c _krb5_context structure
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_default(krb5_context context, krb5_ccache *ccache);

/**
 * @brief Copy a credentials cache.
 *
 * @param context           Context structure [input, output]
 * @param incc              Credentials cache to be copied [input]
 * @param outcc             Copy of credentials cache [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_cc_copy_creds(krb5_context context, krb5_ccache incc, krb5_ccache outcc);

krb5_error_code KRB5_CALLCONV
krb5_cc_get_config(krb5_context context, krb5_ccache id,
                   krb5_const_principal principal,
                   const char *key, krb5_data *data);

krb5_error_code KRB5_CALLCONV
krb5_cc_set_config(krb5_context context, krb5_ccache id,
                   krb5_const_principal principal,
                   const char *key, krb5_data *data);

krb5_boolean KRB5_CALLCONV
krb5_is_config_principal(krb5_context context, krb5_const_principal principal);

/* krb5_free.c */
/**
 * @brief Free a principal structure.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 *
 */
void KRB5_CALLCONV
krb5_free_principal(krb5_context context, krb5_principal val);

/**
 * @brief Free an authenticator structure, including its pointer.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 *
 */
void KRB5_CALLCONV
krb5_free_authenticator(krb5_context context, krb5_authenticator *val);

/**
 * @brief Free an array of addresses and its pointer.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input,output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_addresses(krb5_context context, krb5_address **val);

/**
 * @brief Free an @c _krb5_auth_data structure.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_authdata(krb5_context context, krb5_authdata **val);

/**
 * @brief Free a ticket.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to the data structure to be freed [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_ticket(krb5_context context, krb5_ticket *val);

/**
 * @brief Free an error allocated by either krb5_read_error() or krb5_sendauth().
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 *
 */
void KRB5_CALLCONV
krb5_free_error(krb5_context context, register krb5_error *val);

/**
 * @brief Free a credentials structure and invalidate its pointer.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 *
 */
void KRB5_CALLCONV
krb5_free_creds(krb5_context context, krb5_creds *val);

/**
 * @brief Zero out the session key and free the credentials structure.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to the data structure to be freed [input, output]
 *
 * @note The pointer val is not freed.
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_cred_contents(krb5_context context, krb5_creds *val);

/**
 * @brief Free a @a checksum structure and its pointer.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 *
 */
void KRB5_CALLCONV
krb5_free_checksum(krb5_context context, register krb5_checksum *val);

/**
 * @brief Free the contents of a @a checksum structure.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @note The pointer is not freed.
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_checksum_contents(krb5_context context, register krb5_checksum *val);

/**
 * @brief Free the pointer @a val and zero the contents of the keyblock.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_keyblock(krb5_context context, register krb5_keyblock *val);

/**
 * @brief Free the contents of a keyblock.
 *
 * @param context           Context structure [input, output]
 * @param key               Pointer to data structure to be freed [input, output]
 *
 * @note The pointer is not freed.
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_keyblock_contents(krb5_context context, register krb5_keyblock *key);

/**
 * @brief Free the subkey keyblock (if set)and its pointer.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_ap_rep_enc_part(krb5_context context, krb5_ap_rep_enc_part *val);

/**
 * @brief Free storage associated with a @c krb5_data structure and its pointer.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_data(krb5_context context, krb5_data *val);

/**
 * @brief Free the contents of a @c _krb5_data structure and zero the data field.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to data structure to be freed [input, output]
 *
 * @note The pointer is not freed.
 *
 * @return
 * None
 *
 */
void KRB5_CALLCONV
krb5_free_data_contents(krb5_context context, krb5_data *val);

/**
 * @brief Free a simple character name string returned by krb5_unparse_name().
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to name string to be freed [input, output]
 *
 * @note The pointer is not freed.
 * @return
 * None
 *
 */
void KRB5_CALLCONV
krb5_free_unparsed_name(krb5_context context, char *val);

/**
 * @brief Free an array of checksum types.
 *
 * @param context           Context structure [input, output]
 * @param val               Pointer to checksum type to be freed [input, output]
 *
 * @note Make sure the checksum contents have already been freed.
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_cksumtypes(krb5_context context, krb5_cksumtype *val);

/* From krb5/os but needed but by the outside world */
/**
 * @brief Retrieve the system time of day, in seconds and microseconds, since the local system's epoch.
 *
 * @param context           Context structure [input]
 * @param seconds           System timeofday, seconds portion [output]
 * @param microseconds      System timeofday, microseconds portion [output]
 *
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_us_timeofday(krb5_context context, krb5_timestamp *seconds, krb5_int32 *microseconds);

/**
 * @brief Get the @a timeofday value for the specified timestamp.
 *
 * @param context           Context structure [input, output]
 * @param timeret           Pointer to @a timeofday field in timestamp
 *
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_timeofday(krb5_context context, register krb5_timestamp *timeret);

/* get all the addresses of this host */
/**
 * @brief Return all protocol addresses for this host.
 *
 * @param context           Context structure [input, output]
 * @param addr              Pointer to array of address pointers [output]
 *
 * Compile-time configuration flags indicate which protocol family addresses
 * can be returned.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
*/
krb5_error_code KRB5_CALLCONV
krb5_os_localaddr(krb5_context context, krb5_address ***addr);

/**
 * @brief Retrieve the default realm.
 *
 * @param context           Context structure [input, output]
 * @param lrealm            Pointer to default realm [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_get_default_realm(krb5_context context, char **lrealm);

/**
 * @brief Set the default realm.
 *
 * @param context           Context structure [input, output]
 * @param lrealm             Default realm [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_set_default_realm(krb5_context context, const char *lrealm);

/**
 * @brief Free the default realm string returned by krb5_get_default_realm().
 *
 * @param context           Context structure [input, output]
 * @param lrealm            Realm to be freed [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_default_realm(krb5_context context, char *lrealm);

/**
 * @brief Generate a full principal name from a service name.
 *
 * @param context           Context structure [input, output]
 * @param hostname          Host name, or NULL to use local host [input]
 * @param sname             Service name [input]
 * @param type              Principal type: either @c KRB5_NT_SRV_HST or @c KRB5_NT_UNKNOWN [input]
 * @param ret_princ         Full principal name [output]
 *
 * The full (multi-part) principal name tis used to authenticate the principal with the specified service on the
 * host, given a hostname @a hostname and a generic service name @a sname.
 *
 * @a ret_princ holds the generated full principal name. The realm of the principal
 *  is determined internally by calling krb5_get_host_realm().
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * The principal type, @a type, controls how krb5_sname_to_principal() generates a principal name for a service.
 *
 * @li @c KRB5_NT_SRV_HOST canonicalizes the host name (a fully
 * qualified lowercase @a hostname using the primary name and the
 * domain name), \b before @a ret_princ is generated in the form
 * sname//hostname\@LOCAL.REALM. Most applications should use @a KRB5_NT_SRV_HOST.
 *
 * @li @c KRB5_NT_UNKNOWN generates a  principal name with
 * the form @a sname\/hostname\@LOCAL.REALM, but the @a hostname \b will \b not be
 * canonicalized first. It will appear exactly as it was passed in @a hostname.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_sname_to_principal(krb5_context context, const char *hostname, const char *sname,
                        krb5_int32 type, krb5_principal *ret_princ);

/** Return true if @a princ matches @a matching, false otherwise.
 *
 * A matching principal is a host-based principal with an empty realm and/or
 * second data component (hostname).  Profile configuration may cause the
 * hostname to be ignored even if it is present.  A principal matches a
 * matching principal if the principal has the same non-empty (and non-ignored)
 * components of the matching principal.
 *
 * If @a matching is NULL, return true.  If @a matching is not a matching
 * principal, return the value of krb5_principal_compare(context, matching,
 * princ).
 */
krb5_boolean KRB5_CALLCONV
krb5_sname_match(krb5_context context, krb5_const_principal matching,
                 krb5_const_principal princ);

/**
 * @brief Change the password for an existing Kerberos account.
 *
 * @param context                 Context structure [input, output]
 * @param creds                   Kerberos credentials [input]
 * @param newpw                   New password [input]
 * @param result_code             A numeric error code [output]
 * @param result_code_string      String equivalent to @a result_code [output]
 * @param result_string           Change password response from the KDC [output]
 *
 *
 * @retval
 * 0  Success
 * @retval
 *  KRB5KRB_AP_ERR_MODIFIED       Message stream modified
 * @retval
 *  KRB5KDC_ERR_BAD_PVNO          Requested protocol version not supported
 * @retval
 *  ENOMEM                        Insufficient memory
 * @retval
 *  SOCKET_ERRNO                  Error on socket
 * @retval
 *  ETIMEDOUT                     Connection timed out
 * @retval
 *  EHOSTUNREACH                  No route to host
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_change_password(krb5_context context, krb5_creds *creds, char *newpw,
                     int *result_code, krb5_data *result_code_string,
                     krb5_data *result_string);

/**
 * @brief Implement set password according to RFC 3244, so that it is interoperable with MS Windows implementations.
 *
 * @param context                Context structure [input, output]
 * @param creds                  Credentials [input
 * @param newpw                 New password [input]
 * @param change_password_for   Specific principal for password change  [input]
 * @param result_code           Pointer to result code returned by the remote system [output]
 * @param result_code_string    Pointer to result code translated into a readable message [output]
 * @param result_string         Pointer to result data returned from the remote system [output]
 *
 * @note If @a change_password_for is NULL, the change is performed on the current
 * principal. If @a change_password_for is non-null, the change is performed on the
 * principal name passed in @a change_password_for.
 * @retval
 * 0  Success
 * @retval
 *  INVALID_SOCKET Invalid socket
 * @retval
 *  ECONNREFUSED Connection refused
 *  @retval
 * EHOSTUNREACH Host unreachable
 * @retval
 *  ECONNABORTED Connection aborted
 * @retval
 *  ETIMEDOUT Connection timed out
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_set_password(krb5_context context, krb5_creds *creds, char *newpw,
                  krb5_principal change_password_for, int *result_code,
                  krb5_data *result_code_string, krb5_data *result_string);

/**
 * @brief Implement RFC 3244 set password (interoperable with MS Windows implementations) using the credentials cache instead of explicitly passed credentials.
 *
 * @param context           Context structure [input, output]
 * @param ccache            Credentials cache [input]
 * @param newpw             New password [input]
 * @param change_password_for   Principal for which password is changed [input]
 * @param result_code           Pointer to result code returned from remote system [output]
 * @param result_code_string    Pointer to result code returned from remote system translated into a readable message [output]
 * @param result_string         Pointer to the result data returned from remote system [output]
 *
 * @note If @a change_password_for is set to NULL, the change is performed
 * on the current principal. If @a change_password_for is non null, the change is performed
 * on the specified principal.
 *
 * @retval
 * 0  Success
 * @retval
 *  INVALID_SOCKET Invalid socket
 * @retval
 *  ECONNREFUSED Connection refused
 * @retval
 *  EHOSTUNREACH Host unreachable
 * @retval
 *  ECONNABORTED Connection aborted
 * @retval
 *  ETIMEDOUT Connection timed out
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_set_password_using_ccache(krb5_context context, krb5_ccache ccache,
                               char *newpw, krb5_principal change_password_for,
                               int *result_code, krb5_data *result_code_string,
                               krb5_data *result_string);

/**
 * @brief Retrieve data from a configuration file, typically @c krb5.conf .
 *
 * @param context           Context structure [input, output]
 * @param profile_t         Pointer to data read from a configuration file [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 *  @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_get_profile(krb5_context, struct _profile_t * /* profile_t */ *);

#if KRB5_DEPRECATED
/**   @deprecated Replaced by krb5_get_init_creds_password() */
KRB5_ATTR_DEPRECATED krb5_error_code KRB5_CALLCONV
krb5_get_in_tkt_with_password(krb5_context context, krb5_flags options,
                              krb5_address *const *addrs, krb5_enctype *ktypes,
                              krb5_preauthtype *pre_auth_types,
                              const char *password, krb5_ccache ccache,
                              krb5_creds *creds, krb5_kdc_rep **ret_as_reply);

/** * @deprecated Replaced by krb5_get_init_creds() */
KRB5_ATTR_DEPRECATED krb5_error_code KRB5_CALLCONV
krb5_get_in_tkt_with_skey(krb5_context context, krb5_flags options,
                          krb5_address *const *addrs, krb5_enctype *ktypes,
                          krb5_preauthtype *pre_auth_types,
                          const krb5_keyblock *key, krb5_ccache ccache,
                          krb5_creds *creds, krb5_kdc_rep **ret_as_reply);

 /** @deprecated Replaced by krb5_get_init_creds_keytab() */
KRB5_ATTR_DEPRECATED krb5_error_code KRB5_CALLCONV
krb5_get_in_tkt_with_keytab(krb5_context context, krb5_flags options,
                            krb5_address *const *addrs, krb5_enctype *ktypes,
                            krb5_preauthtype *pre_auth_types,
                            krb5_keytab arg_keytab, krb5_ccache ccache,
                            krb5_creds *creds, krb5_kdc_rep **ret_as_reply);

#endif /* KRB5_DEPRECATED */

/**
 * @brief Parse a @c KRB5-AP-REQ message and return its contents.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [input, output]
 * @param inbuf             Holds the KRB-AP-REQ message to be parsed [input]
 * @param server            Expected server's principal name for the ticket
 * @param keytab            Key table containing decryption key [input]
 * @param ap_req_options    If non-null, the AP-REQ flags on output [input, output]
 * @param ticket            Returned ticket from the AP-REQ message. Use NULL to specify no ticket [output]
 *
 * If @a ticket is set to non-null, it is modified to point to the ticket information.
 *
 * If @c _krb5_auth_context is set to NULL, an @c _krb5_auth_context is generated and freed internally
 * by the function.
 *
 * If @a server is set to NULL, any server name with an appropriate key will be accepted.
 *  Make sure to verify that the server principal name matches some trust
 * criterion.
 *
 * If @a server is set to non-null and a @a replay detection cache has not
 * been established with @c _krb5_auth_context, an @c _krb5_auth_context is generated.
 *
 * If a @a keyblock is present in the @c _krb5_auth_context, it is used to decrypt the ticket
 * request and then must be freed with krb5_free_keyblock(). This is useful for
 * user-to-user authentication.
 *
 * If no @a keyblock is specified, the key table uses an entry matching the requested @a keytype,
 * @a server, and @a version @a number.
 *
 * The authenticator in the request is decrypted and stored in @c _krb5_auth_context.
 * The client specified in the decrypted authenticator is compared to the client
 * specified in the decoded ticket to ensure that the compare was performed.
 *
 * If the @a remote_addr field of @c _krb5_auth_context is set, this routine checks
 * whether the request came from the right client.
 *
 * The replay cache is checked to see if the ticket and authenticator have been seen
 * and, if so, returns an error. If not, the ticket and authenticator are entered into
 * the replay cache.
 *
 * Various other checks are performed on the decoded data, including cross-realm policy,
 * clockskew, and ticket validation times.
 *
 * The @a keyblock, @a subkey, and @a sequence @a number of the request are
 * stored in @c _krb5_auth_context for future use.
 *
 * If the @c AP_OPTS_MUTUAL_REQUIRED bit is set, the local sequence number
 * is XORed with the remote sequence number in the request.
 *
 * @note  A new authentication context is returned if NULL is specified.
 *
 * @note If @a keytab is set to NULL, the default key table is used.
 *
 * @retval
 *  0    Success
 * @retval
 *  KRB5KRB-AP-ERRR-BADADDR Invalid address
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_rd_req(krb5_context context, krb5_auth_context *auth_context,
            const krb5_data *inbuf, krb5_const_principal server,
            krb5_keytab keytab, krb5_flags *ap_req_options,
            krb5_ticket **ticket);

/**
 * @brief Retrieve a service key from a key table.
 *
 * @param context           Context structure [input, output]
 * @param keyprocarg        Name of a key table or NULL to use default key table [input]
 * @param principal         Service principal [input]
 * @param vno               Key version number; use 0 to specify the key with the highest version number [input]
 * @param enctype           Key encryption type; use a keytype of 0 if encryption type does not matter [input]
 * @param key               Returned service key [output]
 *
 * Open and search the specified key table for the entry identified by @a principal, @a enctype,
 * and @a vno. If no key is found, return an error code.
 *
 * The default key table is used, unless @a keyprocarg is non-null. @a keyprocarg designates a specific key table.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_kt_read_service_key(krb5_context context, krb5_pointer keyprocarg,
                         krb5_principal principal, krb5_kvno vno,
                         krb5_enctype enctype, krb5_keyblock **key);

/**
 * @brief Format a @c KRB-SAFE message and store in a buffer.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context
 * @param userdata          User data in the message [input]
 * @param outbuf            Formatted @c KRB-SAFE buffer [output]
 * @param outdata           Sequence numbers if @c KRB5_AUTH_CONTEXT_RET_SEQUENCE is specified in @c _krb5_auth_data
 *
 * The @a _krb5_auth_context->auth_context_flags specify whether sequence numbers or timestamps will
 * be used to identify the message. Valid values are:
 * @li @c  KRB5_AUTH_CONTEXT_DO_TIME  Use timestamps and replay cache.
 * @li @c  KRB5_AUTH_CONTEXT_RET_TIME  Copy timestamp to @a *outdata.
 * @li @c  KRB5_AUTH_CONTEXT_DO_SEQUENCE  Use sequence numbers.
 * @li @c  KRB5_AUTH_CONTEXT_RET_SEQUENCE Copy sequence numbers to @a *outdata.
 *
 * The @a userdata argument is formatted as the user data in the message.
 *
 * Fields in @c _krb5_auth_context specify the checksum type, the keyblock that
 * can be used to seed the checksum, and full addresses (host and port) for
 * the sender and receiver.
 *
 * The @a local_addr field of @c _krb5_auth_context is used to
 * form the addresses used in the @c KRB-SAFE message. The remote_addr is optional;
 * if the receiver's address is  unknown, it can be replaced by NULL.
 * @note The @a local_addr argument is mandatory.
 *
 *  If @c KRB5_AUTH_CONTEXT_DO_TIME is set, an entry describing the message is
 * entered in the replay cache which enables the caller to detect if this message
 * is sent back by an attacker. If @c KRB5_AUTH_CONTEXT_DO_TIME is not set,
 * the replay cache is not used.
 *
 * If either @c KRB5_AUTH_CONTEXT_DO_SEQUENCE or @c KRB5_AUTH_CONTEXT_RET_SEQUENCE is set,
 * the @c _krb5_auth_context local sequence number will be placed in the protected message
 * as its sequence number.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @sa rcache
 */
krb5_error_code KRB5_CALLCONV
krb5_mk_safe(krb5_context context, krb5_auth_context auth_context,
             const krb5_data *userdata, krb5_data *outbuf,
             krb5_replay_data *outdata);

/**
 * @brief Format a @c KRB-PRIV message into @a outbuf.
 *
 * @param context               Context structure [input, output]
 * @param auth_context          Authentication context [input, output]
 * @param userdata              User data in the message [input]
 * @param outbuf                Formatted @c KRB-PRIV buffer [output]
 * @param outdata               Sequence numbers if @c KRB5_AUTH_CONTEXT_RET_SEQUENCE is set [input, output]
 *
 * This function is similar to krb5_mk_safe(), but the message is encrypted @a and
 * integrity-protected, not just integrity-protected.
 *
 * The @a remote_addr and @a remote_port fields of @c _krb5_auth_context are
 * optional; @a local_addr, is mandatory. If the receiver's address is unknown,
 * it can be replaced by NULL.
 *
 * The encryption type is taken from the @a keyblock field in @c _krb5_auth_context.
 *
 * If the @a i_vector field in @c _krb5_auth_context is non-null, it is used
 * as an initialization vector for the encryption (if the chosen encryption
 * type supports initialization vectors), and its contents are replaced with
 * the last block of encrypted data upon return.
 *
 * @note The flags from @c _krb5_auth_context specify whether sequence numbers or timestamps  will be used to identify the message.
 * Valid values are:
 * @li @c KRB5_AUTH_CONTEXT_DO_TIME  Use timestamps and replay cache.
 * @li @c KRB5_AUTH_CONTEXT_RET_TIME  Copy timestamp to @a *outdata.
 * @li @c KRB5_AUTH_CONTEXT_DO_SEQUENCE  Use sequence numbers in replay cache.
 * @li @c KRB5_AUTH_CONTEXT_RET_SEQUENCE  Use sequence numbers in replay cache and output data.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 *
 * @sa KRB-PRIV
 */
krb5_error_code KRB5_CALLCONV
krb5_mk_priv(krb5_context context, krb5_auth_context auth_context,
             const krb5_data *userdata, krb5_data *outbuf,
             krb5_replay_data *outdata);

 /**
 * @brief Send an authenticated message.
 *
 * @param context            Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param fd                 Pointer to file descriptor that describes network socket [input]
 * @param appl_version       String that describes the application protocol version client is expected to use [input]
 * @param client             Client principal name; ignored if @a in_creds is non-null [input]
 * @param server             Server principal name; ignored if @a in_creds is non-null [input]
 * @param ap_req_options     Specifies @c KRB-AP-REQ flags [input]
 * @param in_data            Data to be sent to the server [input]
 * @param in_creds           Input credentials, or NULL [input]
 * @param ccache             Credentials cache [input, output]
 * @param error              If non-null, contains error packet returned from server [output]
 * @param rep_result         If non-null, contains result of mutual authentication exchange [output]
 * @param out_creds         If non-null, the retrieved credentials [output]
 *
 * Send an authenticated message from a client program to a server
 * program using the network connection specified by @a fd. In the MIT UNIX and
 * OpenVMS implementations, @a fd is a pointer to a network socket file descriptor.
 *
 * Valid values for @a ap_req_options are:
 * @li @c  AP_OPTS_USE_SESSION_KEY
 * @li @c AP_OPTS_MUTUAL_REQUIRED  Perform a mutual authentication exchange
 * @li @c AP_OPTS_USE_SUBKEY
 *
 * If @a in_creds is NULL:
 * @li @a server must be non-null
 * @li @a client can be NULL. If @a client is NULL, the credentials cache default principal is used.
 *
 * If @a in_creds is non-null, @a in_creds->client and @a in_creds->server must be
 * filled in. If the other structure fields are filled in with valid credentials,
 * @a in_creds->ticket.length must be zero.
 *
 * If @a rep_result is non-null, it is filled in with the result of the mutual
 * authentication exchange.
 *
 * If @a in_creds->ticket.length is nonzero, @a in_creds is used
 * as the credentials to send to the server, and @a ccache is ignored. Otherwise,
 * @a ccache is used.
 *
 * If @a out_creds, is non-null, it is filled in with the retrieved credentials.
 *
 * @a ccache specifies the credential cache to use @a only when @a in_creds is
 * NULL or @a in_creds->ticket.length is zero.
 *
 * If @a in_creds is NULL or @a in_creds->ticket.length is zero and @a ccache is NULL,
 * If the default credential cache does not contain the needed credentials,
 * the credentials will be retrieved from the KDC and stored in the credential cache.
 *
 * If mutual authentication is used and @a rep_result is non-null, the sequence number
 * for the server is in *rep_result-\>seq_number. If mutual authentication is not
 * used, there is no way to negotiate a sequence number for the server.
 *
 * If the server is using a different application protocol than that specified in
 * @a appl_version, an error will be returned.
 *
 * If an error occurs during the authenticated message exchange and @a error is non-null,
 * the error packet (if any)  sent from the server will be placed in it.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_sendauth(krb5_context context, krb5_auth_context *auth_context,
              krb5_pointer fd, char *appl_version, krb5_principal client,
              krb5_principal server, krb5_flags ap_req_options,
              krb5_data *in_data, krb5_creds *in_creds, krb5_ccache ccache,
              krb5_error **error, krb5_ap_rep_enc_part **rep_result,
              krb5_creds **out_creds);

/**
 * @brief Receive an authenticated message.
 *
 * @param context            Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param fd                 Pointer to file descriptor of network socket [input]
 * @param appl_version       String describing the expected application protocol version. [input]
 * @param server             Server principal [input]
 * @param flags              Additional specifications; nonlibrary callers should use 0. [input]
 * @param keytab            Decryption key [input]
 * @param ticket              Ticket (optional); only filled in with client ticket data if non-null [output]
 *
 * This routine, paired with krb5_sendauth(), provides a way for client and server programs to
 * send authenticated messages to one another through network connections.
 *
 * krb5_recvauth() engages in an authentication dialog with the client program running krb5_sendauth()
 * to authenticate the client to the server.
 *
 * Upon request from the client, krb5_recvauth() provides mutual authentication
 * to ensure the legitimacy of the server represented by krb5_recvauth().
 *
 * The @a fd argument is a pointer to the network connection. As in krb5_sendauth()
 * in the MIT UNIX and OpenVMS implementations, @a fd is a pointer to a file descriptor.
 *
 * @a server, @c _krb5_auth_context, and @a keytab are used to obtain the server's private key.
 *
 * @note
 * @li  if client uses a different application protocol than that specified in @a appl_version,
 * an error is returned and the authentication exchange is aborted.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 *
 * @todo link to flags?
 */
krb5_error_code KRB5_CALLCONV
krb5_recvauth(krb5_context context, krb5_auth_context *auth_context,
              krb5_pointer fd, char *appl_version, krb5_principal server,
              krb5_int32 flags, krb5_keytab keytab, krb5_ticket **ticket);

/**
 * @brief Send authentication messages between client and server using the network.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param fd                Socket from which to read the client response [input]
 * @param server            Verify the server principal is the same as  requested by client; if NULL, an error is returned and the exchange is aborted [input]
 * @param flags
 * @param keytab            Decryption key [input]
 * @param ticket            Optional, if non-null, filled with ticket data sent by the client [output]
 * @param version           Pointer to application version string [output]
 *
 * This routine provides a convenient means for client and server programs to send authenticated messages to
 * one another through network connections. (k5b5_sendauth() is the matching routine to krb5_recvauth_version() for the server.)
 *
 * krb5_recvauth_version() engages in an authentication dialog with the client program running
 * krb5_sendauth() to authenticate the client to the server. In addition, if requested by the client,
 * krb5_recvauth_version() provides mutual authentication to prove to the client that the server represented by
 * krb5_recvauth_version() is legitimate.
 *
 * @a fd  is a pointer to the network connection. As in krb5_sendauth(), in the MIT UNIX and
 * OpenVMS implementations, @a fd is a pointer to a file descriptor.
 *
 * The arguments @a server, @c _krb5_auth_context, and @a keytab are used by @c krb5_rd_req() to obtain the
 * server's private key.
 *
 * If server is non-null, the principal component of it is used to determine
 * the replay cache to use. Otherwise, @c krb5_recvauth_version uses the default
 * replay cache.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @retval
 * KRB5_SENDAUTH_BADAUTHVERS Bad sendauth version was sent
 * @retval
 * KRB5_SENDAUTH_BADAPPLVERS Bad application version was sent
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_recvauth_version(krb5_context context,
                      krb5_auth_context *auth_context,
                      /* IN */
                      krb5_pointer fd,
                      krb5_principal server,
                      krb5_int32 flags,
                      krb5_keytab keytab,
                      /* OUT */
                      krb5_ticket **ticket,
                      krb5_data *version);

/**
* @brief Take an array of credentials and format a @c KRB-CRED message to pass to krb5_rd_cred().
*
* @param context            Context structure [input, output]
* @param auth_context       Authentication context [input, output]
* @param ppcreds            Pointer to an array of credentials [input]
* @param ppdata             Unused
* @param outdata            Pointer to @c KRB-CRED message [output]
*
* @todo Described ppdata as not used, cut " A pointer to a krb5_data structure
*
* @retval
*   0 Success
* @retval
*  ENOMEM Insufficient memory
* @retval
*   KRB5_RC_REQUIRED Message replay detection requires @a rcache parameter
* @return
* Kerberos error codes
*/
krb5_error_code KRB5_CALLCONV
krb5_mk_ncred(krb5_context context, krb5_auth_context auth_context,
              krb5_creds **ppcreds, krb5_data **ppdata,
              krb5_replay_data *outdata);

/**
 * @brief Encode a @c KRB-CRED message to pass to krb5_rd_cred().
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input}
 * @param pcreds            Pointer to credentials [input]
 * @param ppdata            Unused
 * @param outdata           Pointer to @c KRB-CRED message [output]
 *
 * This is a convenience function that calls krb5_mk_ncred() with a single set
 * of credentials.
 *
 * @retval
 *  0 Success
 * @retval
 *  ENOMEM Insufficient memory
 * @retval
 *  KRB5_RC_REQUIRED   Message replay detection requires @a rcache parameter
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_mk_1cred(krb5_context context, krb5_auth_context auth_context,
              krb5_creds *pcreds, krb5_data **ppdata,
              krb5_replay_data *outdata);

/**
 * @brief Read a @c KRB-CRED message, validate it, and output the nonce and an array of the forwarded credentials.
 *
 * @param context            Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param pcreddata          @c KRB-CRED message [input]
 * @param pppcreds           Array of forwarded credentials [output]
 * @param outdata            Replay data information [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @retval
 *  KRB5_RC_REQUIRED Message replay detection requires @a rcache parameter
 *  @retval
 *  KRB5KRB-AP-ERR-SKEW Clock skew too great
 * @retval
 *  KRB5KRB-AP-ERR-BADORDER Message out of order
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_rd_cred(krb5_context context, krb5_auth_context auth_context,
             krb5_data *pcreddata, krb5_creds ***pppcreds,
             krb5_replay_data *outdata);

/**
 * @brief Get a forwarded ticket and format a KRB-CRED message.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output]
 * @param rhost             Remote host [input, output]
 * @param client            Client principal [input]
 * @param server            Server principal [input]
 * @param cc                Credentials cache handle [input]
 * @param forwardable       Boolean indicating whether TGT should be forwardable [input]
 * @param outbuf            Output buffer containing the TGT
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *   0 Success
 * @retval
 *   ENOMEM Insufficient memory
 * @retval
 *   KRB5_PRINC_NOMATCH Requested principal and ticket do not match
 * @retval
 *   KRB5_NO_TKT_SUPPLIED Request did not supply a ticket
 * @retval
 *   KRB5_CC_BADNAME Credential cache name or principal name malformed
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_fwd_tgt_creds(krb5_context context, krb5_auth_context auth_context,
                   char *rhost, krb5_principal client, krb5_principal server,
                   krb5_ccache cc, int forwardable, krb5_data *outbuf);

/**
 * @brief Initialize a @c _krb5_auth_context structure.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [output]
 *
 * The @c _krb5_auth_context contains all data pertinent to the various authentication routines.
 *
 * By default, @a flags for the context are set to enable the use of the replay cache
 * (krb5_auth_context_do_time()) but not sequence numbers. Use krb5_auth_con_setflags() to change the flags.
 *
 * By default, @a checksum type is set to @c CKSUMTYPE_RSA_MD4_DES. Use krb5_auth_con_setcksumtype()
 * to change the @a checksum type.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_init(krb5_context context, krb5_auth_context *auth_context);

/**
 * @brief Free a @c _krb5_auth_context structure.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [output]
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 * @sa krb5_auth_con_init()
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_free(krb5_context context, krb5_auth_context auth_context);

/**
 * @brief Set the flags for an @c _krb5_auth_context structure.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [output}
 * @param flags             Bit mask representing values set in @c _krb5_auth_context
 *
 * Valid values for @a flags are:
 * @li @c KRB5_AUTH_CONTEXT_DO_TIME  Use timestamps
 * @li @c KRB5_AUTH_CONTEXT_RET_TIME Save timestamps to output structure
 * @li @c KRB5_AUTH_CONTEXT_DO_SEQUENCE  Use sequence numbers
 * @li @c KRB5_AUTH_RET_SEQUENCE  Copy sequence numbers to output structure
 *
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_setflags(krb5_context context, krb5_auth_context auth_context, krb5_int32 flags);

/**
 * @brief Retrieve flags from an @c _krb5_auth_context structure.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param flags             Bit mask representing flags set in @c _krb5_auth_context [input]
 *
 *  Valid values for @a flags are:
 * @li @c KRB5_AUTH_CONTEXT_DO_TIME   Use timestamps.
 * @li @c KRB5_AUTH_CONTEXT_RET_TIME   Save timestamps to output structure.
 * @li @c KRB5_AUTH_CONTEXT_DO_SEQUENCE  Use sequence numbers.
 * @li @c KRB5_AUTH_RET_SEQUENCE   Copy sequence numbers to output structure.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_getflags(krb5_context context, krb5_auth_context auth_context, krb5_int32 *flags);

/**
 * @brief Set the checksum function and set up the data structure used to hold the checksum data.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [input, output}
 * @param func              Function to perform the checksum [input]
 * @param data              Pointer to arbitrary to be received by @a func [input]
 *
 * The checksum data is received when krb5_mk_req_extended() calls it.
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 * @sa krb5_mk_req_extended()
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_set_checksum_func( krb5_context context,
                                 krb5_auth_context  auth_context,
                                 krb5_mk_req_checksum_func func,
                                 void *data);

/**
 * @brief Get the checksum function and the data structure used to hold the checksum data.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [input, output}
 * @param func              Pointer to krb5 function that performs the checksum [output]
 * @param data              Pointer to data [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_get_checksum_func( krb5_context context,
                                 krb5_auth_context auth_context,
                                 krb5_mk_req_checksum_func *func,
                                 void **data);

/**
 * @brief Copy the @a local_addr and @a remote_addr into an @c _krb5_auth_context structure.
 *
 * @param context            Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param local_addr         Local address [input]
 * @param remote_addr        Remote address [input]
 *
 * If either address is NULL, the previous address remains in place.
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV_WRONG
krb5_auth_con_setaddrs(krb5_context context, krb5_auth_context auth_context,
                       krb5_address *local_addr, krb5_address *remote_addr);

/**
 * @brief Retrieve address fields from an @c _krb5_auth_con structure.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param local_addr        Local address [output]
 * @param remote_addr       Remote address [output]
 *
 * If @a local_addr or @a remote_addr is non-null, the memory is freed by krb5_free_address() and then newly allocated.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_getaddrs(krb5_context context, krb5_auth_context auth_context,
                       krb5_address **local_addr, krb5_address **remote_addr);

/**
 * @brief Set @a port fields in a @c _krb5_auth_context structure.
 *
 * @param context           Context structure [input, output]
 * @param auth_context      Authentication context [input, output]
 * @param local_port        Local address [input]
 * @param remote_port       Remote address [input]
 *
 * Copy the @a local_port and @a remote_port addresses into an @c _krb5_auth_context structure.
 * If either address is NULL, the previous address remains in place.
 * These addresses are created by krb5_auth_con_genaddrs().
 *
 * @retval
 *  0 Success
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 *
 * @sa krb5_auth_con_genaddrs()
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_setports(krb5_context context, krb5_auth_context auth_context,
                       krb5_address *local_port, krb5_address *remote_port);

/**
 * @brief Set @a keyblock field in an @c _krb5_auth_context structure to a temporary key.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param keyblock          Server key for incoming request [input]
 *
 * Use before calling krb5_rd_req_decode() for user-to-user
 * authentication when the server has the key and needs it to decrypt
 * the incoming request. Once decrypted, the temporary key is no longer
 * valid, and it is overwritten by the session key sent by the client.
 *
 * @retval
 *  0 Success
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_setuseruserkey(krb5_context context, krb5_auth_context auth_context,
                             krb5_keyblock *keyblock);

/**
 * @brief Retrieve key from a @c _krb5_auth_context structure.
 *
 * @param context            Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param keyblock           Key stored in @c _krb5_auth_context [output]
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_getkey(krb5_context context, krb5_auth_context auth_context,
                     krb5_keyblock **keyblock);

krb5_error_code KRB5_CALLCONV
krb5_auth_con_getkey_k(krb5_context context, krb5_auth_context auth_context,
                       krb5_key *key);

/**
 * @deprecated Replaced by krb5_auth_con_getsendsubkey()
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_getsendsubkey(krb5_context ctx, krb5_auth_context ac, krb5_keyblock **keyblock);

krb5_error_code KRB5_CALLCONV
krb5_auth_con_getsendsubkey_k(krb5_context ctx, krb5_auth_context ac,
                              krb5_key *key);

krb5_error_code KRB5_CALLCONV
krb5_auth_con_getrecvsubkey(krb5_context ctx, krb5_auth_context ac, krb5_keyblock **keyblock);

/**
 * @brief Retrieve a @a recv_subkey keyblock from a _kb5_auth_context structure.
 *
 * @param ctx          Context structure [input, output]
 * @param ac           Authentication context [input, output}
 * @param key          @a recv_subkey keyblock stored in @c _krb5_auth_context
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_getrecvsubkey_k(krb5_context ctx, krb5_auth_context ac, krb5_key *key);

/**
 * @param ctx
 * @param ac              Authentication context [input, output]
 * @param keyblock        Key
 *
 * @retval
 * 0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_setsendsubkey(krb5_context ctx, krb5_auth_context ac,
                            krb5_keyblock *keyblock);

krb5_error_code KRB5_CALLCONV
krb5_auth_con_setsendsubkey_k(krb5_context ctx, krb5_auth_context ac, krb5_key key);

/**
 * @brief Set the @a recv_subkey keyblock in a @c _krb5_auth_context structure.
 *
 * @param ctx           Context structure [input, output]
 * @param ac            Authentication context [input, output}
 * @param keyblock      @a recv_subkey stored in @c _krb5_auth_context [input, output]
 *
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_setrecvsubkey(krb5_context ctx, krb5_auth_context ac,
                            krb5_keyblock *keyblock);

krb5_error_code KRB5_CALLCONV
krb5_auth_con_setrecvsubkey_k(krb5_context ctx, krb5_auth_context ac,
                              krb5_key key);

#if KRB5_DEPRECATED
 /**  @deprecated */
KRB5_ATTR_DEPRECATED krb5_error_code KRB5_CALLCONV
krb5_auth_con_getlocalsubkey(krb5_context context, krb5_auth_context auth_context,
                             krb5_keyblock **keyblock);

 /**  @deprecated Replaced by krb5_auth_con_getrecvsubkey() */
KRB5_ATTR_DEPRECATED krb5_error_code KRB5_CALLCONV
krb5_auth_con_getremotesubkey(krb5_context context, krb5_auth_context auth_context,
                              krb5_keyblock **keyblock);
#endif

/**
 * @brief Retrieve the local sequence number used during authentication and store
 * it in the @a seqnumber field of a @c _krb5_auth_context structure.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param seqnumber         Pointer to memory allocated for storage of local sequence number [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 */

krb5_error_code KRB5_CALLCONV
krb5_auth_con_getlocalseqnumber(krb5_context context, krb5_auth_context auth_context,
                                krb5_int32 *seqnumber);

/**
 * @brief Retrieve the remote sequence number used during authentication, and store it in a @c _krb5_auth_context structure.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param seqnumber         Pointer to memorary allocated to store the remote sequence number [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_getremoteseqnumber(krb5_context context, krb5_auth_context auth_context,
                                 krb5_int32 *seqnumber);

#if KRB5_DEPRECATED
/**  @deprecated Replaced by krb5_auth_con_mk_prv() */
KRB5_ATTR_DEPRECATED krb5_error_code KRB5_CALLCONV
krb5_auth_con_initivector(krb5_context context, krb5_auth_context auth_context);
#endif

/**
 * @brief Set the replay cache used by the authentication routine.
 *
 * @param context            Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param rcache             Replay cache to be set [input]
 *
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_setrcache(krb5_context context, krb5_auth_context auth_context,
                        krb5_rcache rcache);

/**
 * @brief Get an IP address and port and generate a full IP address.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param rcache            @a rccache field from @c _krb5_ auth_context [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV_WRONG
krb5_auth_con_getrcache(krb5_context context, krb5_auth_context auth_context,
                        krb5_rcache *rcache);

/**
 * @brief Retrieve the authenticator used during mutual authentication.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param authenticator     Authenticator used during mutual authentication [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_getauthenticator(krb5_context context, krb5_auth_context auth_context,
                               krb5_authenticator **authenticator);

krb5_error_code KRB5_CALLCONV
krb5_auth_con_set_req_cksumtype(krb5_context context, krb5_auth_context auth_context,
                                krb5_cksumtype cksumtype);

#define KRB5_REALM_BRANCH_CHAR '.'

/*
 * end "func-proto.h"
 */

/*
 * begin stuff from libos.h
 */

/**
 * @brief Read a password from the keyboard input.
 *
 * @param context           Context structure [input]
 * @param prompt            First user prompt when reading password [input]
 * @param prompt2           Second user prompt, or NULL to read password only once [input]
 * @param return_pwd        Returned password [output]
 * @param size_return       During input, maximum size of password;
 * during output, total number of bytes in @a return_pwd [input, output]
 *
 * The first *size_return bytes of the password entered are
 * returned in @a return_pwd. If fewer than *size_return bytes are entered as a password,
 * the remainder of @a return_pwd is zeroed.
 * Upon success, the total number of bytes filled in is stored in *size_return.
 *
 * @a prompt is the prompt for the first reading of a password. It is printed
 * to the terminal, and then a password is read from the keyboard. No newlines
 * or spaces are emitted between the prompt and the cursor, unless the newline/space
 * is included in the prompt.
 *
 * If @a prompt2 is a NULL pointer, the password is read only once.
 *
 * If @a prompt2 is set, it is used as a prompt to read another
 * password in the same manner as described for the first password. After the
 * second password is read, the two passwords are compared, and an error is returned if they are not identical.
 *
 * Echoing is turned off when the password is read.
 *
 * @retval
 *  0   Success
 * @return
 * Error in reading or verifying the password
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_read_password(krb5_context context,
                   const char *prompt, const char *prompt2,
                   char *return_pwd, unsigned int *size_return);

/**
 * @brief Convert a principal name to a local name.
 *
 * @param context           Context structure [input, output]
 * @param aname             Principal name [input]
 * @param lnsize_in         Maximum length name to be filled into @a lname [input]
 * @param lname             Local name [output]
 *
 * Local names, rather than principal names, can be used by programs that
 * translate to an environment-specific  name (for example, a user account
 * name). The translation is  null-terminated in all non-error returns.
 *
 * @retval
 * 0  Success
 * @retval
 *  System errors
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_aname_to_localname(krb5_context context, krb5_const_principal aname,
                        int lnsize_in, char *lname);

/**
 * @brief Get the Kerberos realm names for a host.
 *
 * @param context           Context structure [input]
 * @param host              Host name [input]
 * @param realmsp         Pointer to list of realm names [output]
 *
 *
 * Fill in @a realmsp with a pointer to an @c argv style list of names, terminated with a NULL pointer.
 *
 * If host is NULL, the local host's realms are determined.
 *
 * If there are no known realms for the host, the filled-in pointer is
 * set to NULL.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0   Success
 * @retval
 *  ENOMEM  Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_get_host_realm(krb5_context context, const char *host, char ***realmsp);

/**
 *
 * @param context           Context structure [input, output]
 * @param hdata
 * @param realmsp
 *
 * @todo part of referrals support? param descriptions? added pointer descr.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 */
krb5_error_code KRB5_CALLCONV
krb5_get_fallback_host_realm(krb5_context context,
                             krb5_data *hdata, char ***realmsp);

/**
 * @brief Free memory allocated by krb5_get_host_realm().
 *
 * @param context           Context structure [input]
 * @param realmlist         Pointer to list of realm names [output]
 *
 * @retval
 * 0  Success
 * @return
 *  Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_free_host_realm(krb5_context context, char *const *realmlist);

/**
 * @brief Determine if the local user is authorized to log into an account with a designated principal and username.
 *
 * @param context           Context structure [input]
 * @param principal         Principal name [input]
 * @param luser             Local username [input]
 *
 * @retval
 *  TRUE User is authorized to log in
 * @retval
 *  FALSE User is not authorized to log in
 */
krb5_boolean KRB5_CALLCONV
krb5_kuserok(krb5_context context, krb5_principal principal, const char *luser);

/**
 * @brief Generate a full IP address from @a address and port.
 *
 * @param context           Context structure [input, output]
 * @param auth_context       Authentication context [input, output}
 * @param infd              Input socket file descriptor [input]
 * @param flags             Input flags, defined in @c KRB\$ROOT:[INCLUDE]KRB5.
 *
 * The values for the symbols can be OR'd together. Valid values are:
 *
 * @li @c KRB5_AUTH_CONTEXT_GENERATE_LOCAL_ADDR
 * @li @c KRB5_AUTH_CONTEXT_GENERATE_REMOTE_ADDR
 * @li @c KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR
 * @li @c KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_auth_con_genaddrs(krb5_context context, krb5_auth_context auth_context,
                       int infd, int flags);

/**
 * @brief Set time offset field in a @c _krb5_context structure.
 *
 * @param context           Context structure [input, output]
 * @param seconds           Number of seconds to set in @c time_offset field in @a context [input]
 * @param microseconds      Number of microseconds to set in @c usec_offset field in context [input]
 *
 * Take the @a real @a time as input, and set the time offset fields in the
 * context structure so the @c krb5_time routines return the correct time, as corrected by the difference
 * between the system time and the @a real @a time as passed to this routine.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_set_real_time(krb5_context context, krb5_timestamp seconds, krb5_int32 microseconds);

/**
 * @brief Return the time offsets from the OS context.
 *
 * @param context           Context structure [input, output]
 * @param seconds           Time offset from the OS context, seconds portion [output]
 * @param microseconds      Time offset from the OS context, microseconds portion [output]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0  Success
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_get_time_offsets(krb5_context context, krb5_timestamp *seconds, krb5_int32 *microseconds);

/* str_conv.c */
/**
 * @brief Convert a string to an encryption type.
 *
 * @param string        Pointer to string to convert to an encryption type [input]
 * @param enctypep      Pointer to encryption type [output]
 *
 * @retval
 *  0 Success
 * @retval
 *  EINVAL Invalid parameter
 * @return
 * Kerberos error codes
 * @sa enctype
 */
krb5_error_code KRB5_CALLCONV
krb5_string_to_enctype(char *string, krb5_enctype *enctypep);

/**
 * @brief Convert a string to a salt type.
 *
 * @param string        Pointer to string to convert [input]
 * @param salttypep     Pointer to salt type [output]
 *
 * @retval
 *  0 Success
 * @retval
 *  EINVAL Invalid parameter
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_string_to_salttype(char *string, krb5_int32 *salttypep);

/**
 * @brief Convert a string to a checksum type.
 *
 * @param string        Pointer to the string value to be converted [input]
 * @param cksumtypep    Pointer to checksum type [output]
 *
 * @retval
 * 0 Success
 * @retval
 * EINVAL Invalid parameter
 * @return
 * Kerberos error codes
 *
 * @sa cksumtype
 */
krb5_error_code KRB5_CALLCONV
krb5_string_to_cksumtype(char *string, krb5_cksumtype *cksumtypep);

/**
 * @brief Convert a string to a timestamp.
 *
 * @param string        Pointer to string to convert [input]
 * @param timestampp    Pointer to timestamp [output]
 *
 * @retval
 *   0 Success
 * @retval
 *   EINVAL Invalid parameter
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_string_to_timestamp(char *string, krb5_timestamp *timestampp);

/**
 * @brief Convert a string to a delta time value.
 *
 * @param string    Pointer to string to convert [input]
 * @param deltatp   Pointer to delta time [output]
 *
 * @retval
 *  0 Success
 * @retval
 *  EINVAL Invalid parameter
 * @retval
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_string_to_deltat(char *string, krb5_deltat *deltatp);

/**
 * @brief Convert a Kerberos encryption type value to a string.
 *
 * @param enctype       Encrytion type value to convert [input]
 * @param buffer        Pointer to a buffer to hold encryption type string [output]
 * @param buflen        Maximum length of the string that can fit in @a buffer [input]
 *
 * @retval
 *  0   Success
 * @retval
 *  ENOMEM   Insufficient memory
 * @return
 * Kerberos error codes
 *
 * @sa enctype
 */
krb5_error_code KRB5_CALLCONV
krb5_enctype_to_string(krb5_enctype enctype, char *buffer, size_t buflen);

krb5_error_code KRB5_CALLCONV
krb5_enctype_to_name(krb5_enctype enctype, krb5_boolean shortest,
                     char *buffer, size_t buflen);

/**
 * @brief Convert a @a salttype to a string.
 *
 * @param salttype          Salttype to convert [input]
 * @param buffer            Pointer to buffer to receive the converted string [output]
 * @param buflen            Length of buffer [input]
 *
 *@retval
 *  0  Success
 * @retval
 *  EINVAL Invalid parameter
 * @retval
 *  ENOMEM Insufficient memory (buffer length less than output size)
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_salttype_to_string(krb5_int32 salttype, char *buffer, size_t buflen);

krb5_error_code KRB5_CALLCONV
krb5_cksumtype_to_string(krb5_cksumtype cksumtype, char *buffer, size_t buflen);

/**
 *@brief Convert a timestamp to a string.
 *
 * @param timestamp         Timestamp to be converted [input]
 * @param buffer            Buffer to hold converted timestamp [output]
 * @param buflen            Maximum length of buffer [input]
 *
 * The string is returned in the locale's appropriate date and time representation.
 *
 * @retval
 *  0 Success
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_timestamp_to_string(krb5_timestamp timestamp, char *buffer, size_t buflen);

/**
 * @brief Convert a timestamp to a string, allowing optional padding in the output buffer.
 *
 * @param timestamp     Timestamp to convert [input]
 * @param buffer        Buffer to hold the converted timestamp [output]
 * @param buflen        Length of buffer [input]
 * @param pad           Optional value to pad @a buffer if converted timestamp does not fill it [input]
 *
 * This function also tries multiple possible formats if the default locale-specific fails.
 *
 * @retval
 *  0   Success
 * @retval
 *  ENOMEM   Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_timestamp_to_sfstring(krb5_timestamp timestamp, char *buffer, size_t buflen, char *pad);

/**
 * @brief Convert a relative time value to a string.
 *
 * @param deltat            Relative time value to convert [input]
 * @param buffer            Pointer to buffer to hold time string [output]
 * @param buflen            Maximum length of string that fits in @a buffer [input]
 *
 * @retval
 *  0   Success
 * @retval
 *  ENOMEM  Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_deltat_to_string(krb5_deltat deltat, char *buffer, size_t buflen);

/* The name of the Kerberos ticket granting service... and its size */
#define KRB5_TGS_NAME           "krbtgt"
#define KRB5_TGS_NAME_SIZE      6

/* flags for recvauth */
#define KRB5_RECVAUTH_SKIP_VERSION      0x0001
#define KRB5_RECVAUTH_BADAUTHVERS       0x0002
/* initial ticket api functions */

/**
 * @brief Text for prompt used in prompter callback function.
 */
typedef struct _krb5_prompt {
    char *prompt;
    int hidden;
    krb5_data *reply;
} krb5_prompt;

/**
 * @brief Pointer to a prompter callback function.
 */
typedef krb5_error_code
(KRB5_CALLCONV *krb5_prompter_fct)(krb5_context context, void *data,
                                   const char *name, const char *banner,
                                   int num_prompts, krb5_prompt prompts[]);

/**
 * @brief Prompt user for password.
 *
 * @param context           Context structure [input, output]
 * @param data              Unused
 * @param name              Name to output during prompt [input]
 * @param banner            Banner to output during prompt [input]
 * @param num_prompts       Number of prompts passed in @a prompts [input]
 * @param prompts           Array of krb5_prompt structures containing output prompts and replies [input, output]
 *
 * Prompt the user for the  password associated with the given principal name,
 * and set the reply field of the @a prompts argument to the password input. The hidden
 * flag in the @c prompts structure controls whether the password input is echoed back
 * to the terminal.
 *
 * @retval
 *  0   Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_prompter_posix(krb5_context context, void *data, const char *name,
                    const char *banner, int num_prompts,
                    krb5_prompt prompts[]);

 /**
  * @brief Store options for @c _krb5_get_init_creds
  */
typedef struct _krb5_get_init_creds_opt {
    krb5_flags flags;
    krb5_deltat tkt_life;
    krb5_deltat renew_life;
    int forwardable;
    int proxiable;
    krb5_enctype *etype_list;
    int etype_list_length;
    krb5_address **address_list;
    krb5_preauthtype *preauth_list;
    int preauth_list_length;
    krb5_data *salt;
} krb5_get_init_creds_opt;

#define KRB5_GET_INIT_CREDS_OPT_TKT_LIFE        0x0001
#define KRB5_GET_INIT_CREDS_OPT_RENEW_LIFE      0x0002
#define KRB5_GET_INIT_CREDS_OPT_FORWARDABLE     0x0004
#define KRB5_GET_INIT_CREDS_OPT_PROXIABLE       0x0008
#define KRB5_GET_INIT_CREDS_OPT_ETYPE_LIST      0x0010
#define KRB5_GET_INIT_CREDS_OPT_ADDRESS_LIST    0x0020
#define KRB5_GET_INIT_CREDS_OPT_PREAUTH_LIST    0x0040
#define KRB5_GET_INIT_CREDS_OPT_SALT            0x0080
#define KRB5_GET_INIT_CREDS_OPT_CHG_PWD_PRMPT   0x0100
#define KRB5_GET_INIT_CREDS_OPT_CANONICALIZE    0x0200
#define KRB5_GET_INIT_CREDS_OPT_ANONYMOUS 0x0400


/**
 * @brief Provide extended functionality to krb5_get_init_creds_opt_init() functionality
 *
 * @param context           Context structure [input, output]
 * @param opt               Pointer to @a opts field in @c _krb5_get_init_creds_opt [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @sa getinitcreds
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_alloc(krb5_context context,
                              krb5_get_init_creds_opt **opt);

/**
 * @brief Free the extended options allocated by krb5_get_init_creds_opt_alloc().
 *
 * @param context           Context structure [input, output]
 * @param opt               Pointer to extended options field in  @c _krb5_get_init_creds_opt [input]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_free(krb5_context context,
                             krb5_get_init_creds_opt *opt);

/**
 * @brief Set @a opt field of @c _krb5_get_init_creds_opt to zero.
 *
 * @param opt           Pointer to @c _krb5_get_init_creds_opt [input, output]
 *
 * @note Call this function on an options structure on which krb5_init_creds_opt_alloc() has been called.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_init(krb5_get_init_creds_opt *opt);

/**
 * @brief Initialize the ticket lifetime field in @c _krb5_get_init_creds_opt.
 *
 * @param opt           Pointer to structure containing flags and options [input, output]
 * @param tkt_life      Ticket lifetime [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_tkt_life(krb5_get_init_creds_opt *opt,
                                     krb5_deltat tkt_life);

/**
 * @brief Set the ticket renewal lifetime field in @c _krb5_get_init_creds_opt.
 *
 * @param opt               Pointer to @a options field [output]
 * @param renew_life        Ticket renewal lifetime [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_renew_life(krb5_get_init_creds_opt *opt,
                                       krb5_deltat renew_life);

/**
 * @brief Set the forwardable field in @c _krb5_get_init_creds_opt.
 *
 * @param opt               Pointer to options field [output]
 * @param forwardable       Flag indicating whether credentials are forwardable [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_forwardable(krb5_get_init_creds_opt *opt,
                                        int forwardable);

/**
 * @brief Set the proxiable field in @c _krb5_get_init_creds_opt.
 *
 * @param opt           Pointer to options field [output]
 * @param proxiable     Flag indicating whether credentials are proxiable [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_proxiable(krb5_get_init_creds_opt *opt,
                                      int proxiable);

void KRB5_CALLCONV
krb5_get_init_creds_opt_set_canonicalize(krb5_get_init_creds_opt *opt,
                                         int canonicalize);

/**
 * Request anonymous credentials from the KDC.  If the  client name looks like
 * "@REALM" (an empty principal name), then fully anonymous credentials are
 * requested.  If the client name looks like "name@REALM," then credentials
 * tied to a specific realm are requested.
 *
 * Credentials tied to a specific realm are not supported in this version.
 *
 * Note that anonymous credentials are only a request; clients must verify that
 * credentials are anonymous if that is a requirement.
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_anonymous(krb5_get_init_creds_opt *opt,
                                      int anonymous);

/**
 *@brief Set the encryption list field in the @c _krb5_get_init_creds_opt.
 *
 * @param opt                    Pointer to options field [output]
 * @param etype_list             Pointer to the encryption type to set [input]
 * @param etype_list_length      Length of the etype_list field [input]
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * @return
 *  None
 *
 * @sa enctype
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_etype_list(krb5_get_init_creds_opt *opt,
                                       krb5_enctype *etype_list,
                                       int etype_list_length);

/**
 * @brief Set the address list in  @c _krb5_get_init_creds_opt.
 *
 * @param opt               Pointer to options field [output]
 * @param addresses         Pointer to the address to set [input]
 *
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_address_list(krb5_get_init_creds_opt *opt,
                                         krb5_address **addresses);

/**
 * @brief Set the @a preauth_list field in @c _krb5_get_init_creds_opt.
 *
 * @param opt                       Pointer to options field [output]
 * @param preauth_list              Pointer to Pre-athentication type [input]
 * @param preauth_list_length       Length of @a preauth_list field [input]
 *
 * @sa padata
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_preauth_list(krb5_get_init_creds_opt *opt,
                                         krb5_preauthtype *preauth_list,
                                         int preauth_list_length);

void KRB5_CALLCONV
krb5_get_init_creds_opt_set_salt(krb5_get_init_creds_opt *opt,
                                 krb5_data *salt);

/**
 * @brief Set flag in @c _krb5_get_init_creds_opt that determines whether to prompt for a password
 *
 * @param opt            Pointer to @c _krb5_get_init_creds_opt
 * @param prompt         Prompt to change password
 *
 * change for an expired password.
 *
 * @return
 * None
 * @sa getinitcreds
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_set_change_password_prompt(krb5_get_init_creds_opt
                                                   *opt, int prompt);

/** @brief  Generic preauth option attribute/value pairs */
typedef struct _krb5_gic_opt_pa_data {
    char *attr;
    char *value;
} krb5_gic_opt_pa_data;

/**
 * @brief Validate options passed to @a preauth plugins by krb5_get_init_creds_opt_alloc().
 *
 * @param context           Context structure [input, output]
 * @param opt               Pre options [input]
 * @param attr              Pre attribute [input]
 * @param value             Pre value [input]
 *
 * @retval
 * 0  Success
 * @return
 * Kerberos error codes
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * This function allows the caller to supply options to preauth
 * plugins.  Preauth plugin modules are given a chance to look
 * at each option at the time this function is called in ordre
 * to check the validity of the option.
 * The 'opt' pointer supplied to this function must have been
 * obtained using krb5_get_init_creds_opt_alloc()
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_set_pa(krb5_context context,
                               krb5_get_init_creds_opt *opt, const char *attr,
                               const char *value);

/**
 * This API sets a ccache name that will contain some TGT on calls to
 * t_init_creds functions.  If set, this ccache will be used for FAST
 * (draft-ietf-krb-wg-preauth-framework) to protect the AS-REQ from observation
 * and active attack.  If the fast_ccache_name is set, then FAST may be
 * required by the client library.  In this and future versions, FAST will be
 * used if available; krb5_get_init_creds_opt_set_fast_flags() may be used to
 * require that the request fail is FAST is unavailable.  In MIT Kerberos 1.7
 * setting the fast ccache at all required that FAST be present or the request
 * would fail.
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_set_fast_ccache_name(krb5_context context,
                                             krb5_get_init_creds_opt *opt,
                                             const char *fast_ccache_name);

/** Set the FAST ccache name as in
 * krb5_get_init_creds_opt_set_fast_ccache_name() but using a krb5_ccache
 * rather than a name.
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_set_fast_ccache(krb5_context context,
                                        krb5_get_init_creds_opt *opt,
                                        krb5_ccache fast_ccache_name);

/**
 * Set a ccache where resulting credentials will be stored.  If set, then the
 * krb5_get_init_creds family of APIs will write out credentials to the given
 * ccache.  Setting an output ccache is desirable both because it simplifies
 * calling code and because it permits the krb5_get_init_creds APIs to write
 * out configuration information about the realm to the ccache.
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_set_out_ccache(krb5_context context,
                                       krb5_get_init_creds_opt *opt,
                                       krb5_ccache ccache);

krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_set_fast_flags(krb5_context context,
                                       krb5_get_init_creds_opt *opt,
                                       krb5_flags flags);

krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_get_fast_flags(krb5_context context,
                                       krb5_get_init_creds_opt *opt,
                                       krb5_flags *out_flags);

/* Fast flags*/
#define KRB5_FAST_REQUIRED 1l<<0 /**< Require KDC to support FAST*/

typedef void
(KRB5_CALLCONV *krb5_expire_callback_func)(krb5_context context, void *data,
                                           krb5_timestamp password_expiration,
                                           krb5_timestamp account_expiration,
                                           krb5_boolean is_last_req);

/**
 * @brief Set a callback to receive password and account expiration times.
 *
 * This option only applies to krb5_get_init_creds_password().  @a cb will be
 * invoked if and only if credentials are successfully acquired.  The callback
 * will receive the @a context from the krb5_get_init_creds_password() call and
 * the @a data argument supplied with this API.  The remaining arguments should
 * be interpreted as follows:
 *
 * If @a is_last_req is true, then the KDC reply contained last-req entries
 * which unambiguously indicated the password expiration, account expiration,
 * or both.  (If either value was not present, the corresponding argument will
 * be 0.)  Furthermore, a non-zero @a password_expiration should be taken as a
 * suggestion from the KDC that a warning be displayed.
 *
 * If @a is_last_req is false, then @a account_expiration will be 0 and @a
 * password_expiration will contain the expiration time of either the password
 * or account, or 0 if no expiration time was indicated in the KDC reply.  The
 * callback should independently decide whether to display a password
 * expiration warning.
 *
 * Note that @a cb may be invoked even if credentials are being acquired for
 * the kadmin/changepw service in order to change the password.  It is the
 * caller's responsibility to avoid displaying a password expiry warning in
 * this case.
 *
 * Setting an expire callback with this API will cause
 * krb5_get_init_creds_password() not to send password expiry warnings to the
 * prompter, as it ordinarily may.
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_set_expire_callback(krb5_context context,
                                            krb5_get_init_creds_opt *opt,
                                            krb5_expire_callback_func cb,
                                            void *data);

/**
 * @brief Get initial credentials using a password.
 *
 * @param context           Context structure [input, output]
 * @param creds             Pointer to credentials structure [output]
 * @param client            Client principal [input]
 * @param password          Password associated with initial credentials [input, output]
 * @param prompter          Pointer to password prompt routine [input]
 * @param data              Data for password prompt routine [input]
 * @param start_time        Time that credentials first became valid [input]
 * @param in_tkt_service    Pointer to output buffer containing the TGT [input]
 * @param k5_gic_options    Pointer to structure containing flags and options [input]
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0    Success
 * @retval
 *  EINVAL Invalid argument
 * @retval
 *  KRB5_KDC_UNREACH Cannot contact any KDC for requested realm
 * @retval
 *  KRB5_PREAUTH_FAILED Generic Pre-athentication failure
 * @retval
 *  KRB5_LIBOS_PWDINTR Password read interrupted
 * @retval
 *  KRB5_REALM_CANT_RESOLVE Cannot resolve network address for KDC in requested realm
 * @retval
 *  KRB5KDC_ERR_KEY_EXP Password has expired
 * @retval
 *  KRB5_LIBOS_BADPWDMATCH Password mismatch
 * @retval
 *  KRB5_CHPW_PWDNULL New password cannot be zero length
 * @retval
 *  KRB5_CHPW_FAIL Password change failed
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_password(krb5_context context, krb5_creds *creds,
                             krb5_principal client, char *password,
                             krb5_prompter_fct prompter, void *data,
                             krb5_deltat start_time, char *in_tkt_service,
                             krb5_get_init_creds_opt *k5_gic_options);

struct _krb5_init_creds_context;
typedef struct _krb5_init_creds_context *krb5_init_creds_context;

#define KRB5_INIT_CREDS_STEP_FLAG_CONTINUE 0x1  /* More responses needed */

void KRB5_CALLCONV
krb5_init_creds_free(krb5_context context, krb5_init_creds_context ctx);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_get(krb5_context context, krb5_init_creds_context ctx);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_get_creds(krb5_context context, krb5_init_creds_context ctx,
                          krb5_creds *creds);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_get_error(krb5_context context, krb5_init_creds_context ctx,
                          krb5_error **error);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_init(krb5_context context, krb5_principal client,
                     krb5_prompter_fct prompter, void *data,
                     krb5_deltat start_time, krb5_get_init_creds_opt *options,
                     krb5_init_creds_context *ctx);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_set_keyblock(krb5_context context, krb5_init_creds_context ctx,
                             krb5_keyblock *keyblock);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_set_keytab(krb5_context context, krb5_init_creds_context ctx,
                           krb5_keytab keytab);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_step(krb5_context context, krb5_init_creds_context ctx,
                     krb5_data *in, krb5_data *out, krb5_data *realm,
                     unsigned int *flags);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_set_password(krb5_context context, krb5_init_creds_context ctx,
                             const char *password);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_set_service(krb5_context context, krb5_init_creds_context ctx,
                            const char *service);

krb5_error_code KRB5_CALLCONV
krb5_init_creds_get_times(krb5_context context, krb5_init_creds_context ctx,
                          krb5_ticket_times *times);

struct _krb5_tkt_creds_context;
typedef struct _krb5_tkt_creds_context *krb5_tkt_creds_context;

/**
 * @brief Create a context to get credentials from a KDC's Ticket Granting Service.
 *
 * @param[in]  context  A krb5 library context (see krb5_init_context())
 * @param[in]  ccache   A credentials cache containing the desired credentials
 *                      or a Ticket Granting Ticket (TGT) for the client realm.
 *                      TGT and service credentials may be stored into this
 *                      cache as they are acquired.
 * @param creds
 * @param[in]  options  KRB5_GC_* options for this request.
 * @param[out] ctx      The TGS acquisition context.
 *
 * The resulting TGS acquisition context can be used asynchronously with
 * krb5_tkt_creds_step() or synchronously with krb5_tkt_creds_get().  See also
 * krb5_get_credentials() for synchrous use.
 */
krb5_error_code KRB5_CALLCONV
krb5_tkt_creds_init(krb5_context context, krb5_ccache ccache,
                    krb5_creds *creds, krb5_flags options,
                    krb5_tkt_creds_context *ctx);

/**
 * @brief Synchronously obtain credentials within an acquisition context.
 *
 * @param[in]  context  A krb5 library context (see krb5_init_context())
 * @param[in]  ctx      A TGS acquisition context (see krb5_tkt_creds_init())
 *
 * This function repeatedly generates requests, sends them to the appropriate
 * realms' KDCs, and processes the replies until credentials are available for
 * retrieval with krb5_tkt_creds_get_creds().
 */
krb5_error_code KRB5_CALLCONV
krb5_tkt_creds_get(krb5_context context, krb5_tkt_creds_context ctx);

/**
 * @brief Retrieve credentials from an acquisition context, filling in @a creds.
 *
 * @param[in]  context  A krb5 library context (see krb5_init_context())
 * @param[in]  ctx      A TGS acquisition context (see krb5_tkt_creds_init())
 * @param[out] creds    The acquired credentials
 *
 * The acquisition context must have completed obtaining credentials via either
 * krb5_tkt_creds_get() or krb5_tkt_creds_step().
 */
krb5_error_code KRB5_CALLCONV
krb5_tkt_creds_get_creds(krb5_context context, krb5_tkt_creds_context ctx,
                         krb5_creds *creds);

/**
 * @brief Release the resources used by an acquisition context.
 *
 * @param[in]  context  A krb5 library context (see krb5_init_context())
 * @param[in]  ctx      A TGS acquisition context (see krb5_tkt_creds_init())
 */
void KRB5_CALLCONV
krb5_tkt_creds_free(krb5_context context, krb5_tkt_creds_context ctx);

#define KRB5_TKT_CREDS_STEP_FLAG_CONTINUE 0x1  /* More responses needed. */

/**
 * @brief Process a response and generate the next request to acquire credentials.
 *
 * @param[in]  context  A krb5 library context (see krb5_init_context())
 * @param[in]  ctx      A TGS acquisition context (see krb5_tkt_creds_init())
 * @param[in]  in       The last response (empty or NULL for first call)
 * @param[out] out      The next request to be sent
 * @param[out] realm    The realm to which the next request should be sent
 * @param[out] flags    Indicates whether more responses are needed
 *
 * On the first call, @a in should be empty or NULL.  If more responses are
 * needed, the @a flags output parameter will contain @a
 * KRB5_TKT_CREDS_STEP_FLAG_CONTINUE.  In that case, the caller must transport
 * @a out to a KDC for @a realm and receive a response, which should be
 * provided as @a in to the next call.
 */
krb5_error_code KRB5_CALLCONV
krb5_tkt_creds_step(krb5_context context, krb5_tkt_creds_context ctx,
                    krb5_data *in, krb5_data *out, krb5_data *realm,
                    unsigned int *flags);

/**
 * @brief Retrieve ticket times for obtained credentials, filling in @a times.
 *
 * @param[in]  context  A krb5 library context (see krb5_init_context())
 * @param[in]  ctx      A TGS acquisition context (see krb5_tkt_creds_init())
 * @param[out] times    Ticket times for the acquired credentials
 *
 * The acquisition context must have completed obtaining credentials via either
 * krb5_tkt_creds_get() or krb5_tkt_creds_step().
 */
krb5_error_code KRB5_CALLCONV
krb5_tkt_creds_get_times(krb5_context context, krb5_tkt_creds_context ctx,
                         krb5_ticket_times *times);

/**
 * @brief Get initial credentials using a key table.
 *
 * @param context           Context structure [input, output]
 * @param creds             Pointer to credentials structure [output]
 * @param client            Client princiapl [input]
 * @param arg_keytab        Key table handle [input]
 * @param start_time        Time when a ticket becomes valid [input]
 * @param in_tkt_service    Requesting server's principal name [input]
 * @param k5_gic_options    Pointer to a structure containing flags and options [input]
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *  0 Success
 * @retval
 *  ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_keytab(krb5_context context, krb5_creds *creds,
                           krb5_principal client, krb5_keytab arg_keytab,
                           krb5_deltat start_time, char *in_tkt_service,
                           krb5_get_init_creds_opt *k5_gic_options);

typedef struct _krb5_verify_init_creds_opt {
    krb5_flags flags;
    int ap_req_nofail;
} krb5_verify_init_creds_opt;

#define KRB5_VERIFY_INIT_CREDS_OPT_AP_REQ_NOFAIL        0x0001

/**
 * @brief Initialize the @a flags field in @c _krb5_verify_init_creds_opt.
 *
 * @param k5_vic_options       Pointer to options field [output]
 *
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_verify_init_creds_opt_init(krb5_verify_init_creds_opt *k5_vic_options);

/**
 * @brief Initialize the @a ap_req_nofail field in @c _krb5_verify_init_creds_opt.
 *
 * @param k5_vic_options                   Pointer to  options field [output]
 * @param ap_req_nofail         Value to set for the ap_req_nofail field [input]
 *
 * @return
 *  None
 * @todo is @c ap_req_nofail parameter description accurate?
 */
void KRB5_CALLCONV
krb5_verify_init_creds_opt_set_ap_req_nofail(krb5_verify_init_creds_opt *
                                             k5_vic_options,
                                             int ap_req_nofail);

/**
 * @brief  Verify initial credentials and store them in the credentials cache.
 *
 * @param context              Context structure [input, output]
 * @param creds                Pointer to initial credentials [input]
 * @param ap_req_server        Server principal [input]
 * @param ap_req_keytab           Key table entry [input]
 * @param ccache                Pointer to credentials cache [input, output]
 * @param k5_vic_options        Pointer to structure containing flags and options [input]
 *
 * @retval
 *  0 Success
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_verify_init_creds(krb5_context context, krb5_creds *creds,
                       krb5_principal ap_req_server, krb5_keytab ap_req_keytab,
                       krb5_ccache *ccache,
                       krb5_verify_init_creds_opt *k5_vic_options);

/**
 * @brief Get validated credentials from the KDC.
 *
 * @param context           Context structure [input, output]
 * @param creds             Pointer to credentials structure [output]
 * @param client            Client principal [input]
 * @param ccache            Credentials cache [input]
 * @param in_tkt_service    Pointer to principal name of requesting server.
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *   0 Success
 * @retval
 *  KRB5_NO_2ND_TKT Request missing second ticket
 * @retval
 *  KRB5_NO_TKT_SUPPLIED Request did not supply a ticket
 * @retval
 * KRB5_PRINC_NOMATCH Requested principal and ticket do not match
 * @retval
 * KRB5_KDCREP_MODIFIED KDC reply did not match expectations
 * @retval
 * KRB5_KDCREP_SKEW Clock skew too great in KDC reply
 * @retval
 * ENOMEM Insufficient memory
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_get_validated_creds(krb5_context context, krb5_creds *creds,
                         krb5_principal client, krb5_ccache ccache,
                         char *in_tkt_service);

/**
 * @brief Renew a set of existing Kerberos credentials.
 *
 * @param context           Context structure [input, output]
 * @param creds             Pointer to credentials structure [output]
 * @param client            Client principal name [input]
 * @param ccache            Credentials cache [input]
 * @param in_tkt_service    Pointer to principal name of requesting server [input]
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @retval
 *   0 Success
 * @retval
 *   ENOMEM Insufficient memory
 * @retval
 *   KRB5_PROG_ETYPE_NOSUPP Encryption type is not supported
 * @return
 * Kerberos error codes
 */
krb5_error_code KRB5_CALLCONV
krb5_get_renewed_creds(krb5_context context, krb5_creds *creds,
                       krb5_principal client, krb5_ccache ccache,
                       char *in_tkt_service);

/**
 * @brief Decode a formatted ticket.
 *
 * @param code          Formatted ticket [input]
 * @param rep           Decoded ticket information [output]
 *
 * @retval
 *   0 Success
 * @retval
 *   KRB5KDC_ERR_BAD_PVNO Bad key version number
 * @return
 * Kerberos error codes
 *
 */
krb5_error_code KRB5_CALLCONV
krb5_decode_ticket(const krb5_data *code, krb5_ticket **rep);

/**
 * @brief Check the @a appdefaults section of the @c krb5.conf file.
 *
 * @param context           Context structure [input, output]
 * @param appname           Pointer to application name [input]
 * @param realm             Pointer to realm name [input]
 * @param option            Pointer to option to be checked [input]
 * @param default_value     Default Boolean value to return if no match is found [input]
 * @param ret_value         Pointer to returned string value of @a option [output]
 *
 * Use @a krb5_appdefault_boolean to check Boolean values in the @a [appdefaults] section
 * of @c krb5.conf.
 *
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_appdefault_string(krb5_context context, const char *appname,
                       const krb5_data *realm, const char *option,
                       const char *default_value, char ** ret_value);

/**
 * @brief Check Boolean values in @a [appdefaults] section of @c krb5.config file.
 *
 * @param context           Context structure [input]
 * @param appname           Pointer to application name [input]
 * @param realm             Pointer to realm name [input]
 * @param option            Pointer to option to be checked [input]
 * @param default_value     Default Boolean value to return if no match is found [input]
 * @param ret_value         Pointer to returned Boolean value [output]
 *
 * @a ret_value returns the Boolean value of the specified option
 * passed in the @a option argument. @a appname specifies the
 * application name (for example, Telnet) for the option being checked.
 *
 * Use krb5_appdefault_string() to check string values in the @a [appdefaults] section of
 * @c krb5.conf.
 *
 * @return
 *  None
 */
void KRB5_CALLCONV
krb5_appdefault_boolean(krb5_context context, const char *appname,
                        const krb5_data *realm, const char *option,
                        int default_value, int *ret_value);

/*
 * Prompter enhancements
 */

#define KRB5_PROMPT_TYPE_PASSWORD            0x1
#define KRB5_PROMPT_TYPE_NEW_PASSWORD        0x2
#define KRB5_PROMPT_TYPE_NEW_PASSWORD_AGAIN  0x3
#define KRB5_PROMPT_TYPE_PREAUTH             0x4

typedef krb5_int32 krb5_prompt_type;

/**
 * @brief Get @a prompt_types field from a context.
 *
 * @param context           Context structure [input, output]
 *
 *  Make sure to free the allocated memory when it is no longer needed.
 *
 * @return
 * Pointer to the @a krb5_prompt_type field, which contains one of the following values:
 *  @li  @c KRB5_PROMPT_TYPE_PASSWORD
 *  @li  @c KRB5_PROMPT_TYPE_NEW_PASSWORD
 *  @li  @c KRB5_PROMPT_TYPE_NEW_PASSWORD_AGAIN
 *  @li  @c KRB5_PROMPT_TYPE_PREAUTH
*/
krb5_prompt_type* KRB5_CALLCONV
krb5_get_prompt_types(krb5_context context);

/* Error reporting */
void KRB5_CALLCONV_C
krb5_set_error_message(krb5_context, krb5_error_code, const char *, ...)
#if !defined(__cplusplus) && (__GNUC__ > 2)
    __attribute__((__format__(__printf__, 3, 4)))
#endif
    ;
void KRB5_CALLCONV
krb5_vset_error_message(krb5_context, krb5_error_code, const char *, va_list)
#if !defined(__cplusplus) && (__GNUC__ > 2)
    __attribute__((__format__(__printf__, 3, 0)))
#endif
    ;
void KRB5_CALLCONV
krb5_copy_error_message (krb5_context dest_ctx, krb5_context src_ctx);

/**
 * @brief Get extended error information.
 *
 * @param ctx           Context structure [input, output]
 * @param code          Error code [input, output??]
 *
 * The behavior of krb5_get_error_message is only defined the first
 * time it is called after a failed call to a krb5 function using the
 * same context, and only when the error code passed in is the same as
 * that returned by the krb5 function.  Future versions may return the
 * same string for the second and following calls.  This function never
 * returns NULL, so its result may be used unconditionally as a C
 * string.
 *
 * Make sure to free the allocated memory when it is no longer needed.
 *
 * The string returned by this function must be freed using
 * krb5_free_error_message.
 */
const char * KRB5_CALLCONV
krb5_get_error_message(krb5_context ctx, krb5_error_code code);

/**
 * @brief Free an extended error message generated by krb5_get_error_message().
 *
 * @param cxt           Context structure [input, output]
 * @param msg           Pointer to error message [input, output]
 *
 * @return
 * None
 */
void KRB5_CALLCONV
krb5_free_error_message(krb5_context cxt, const char *msg);

/**
 * @brief Clear the extended error message state.
 *
 * @param ctx           Context structure [input, output]
 * @return
 * None
 *
 * @todo link to extended message state
 */
void KRB5_CALLCONV
krb5_clear_error_message(krb5_context ctx);

krb5_error_code KRB5_CALLCONV
krb5_decode_authdata_container(krb5_context context,
                               krb5_authdatatype type,
                               const krb5_authdata *container,
                               krb5_authdata ***authdata);

krb5_error_code KRB5_CALLCONV
krb5_encode_authdata_container(krb5_context context,
                               krb5_authdatatype type,
                               krb5_authdata * const*authdata,
                               krb5_authdata ***container);

/*
 * AD-KDCIssued
 */
krb5_error_code KRB5_CALLCONV
krb5_make_authdata_kdc_issued(krb5_context context,
                              const krb5_keyblock *key,
                              krb5_const_principal issuer,
                              krb5_authdata *const *authdata,
                              krb5_authdata ***ad_kdcissued);

krb5_error_code KRB5_CALLCONV
krb5_verify_authdata_kdc_issued(krb5_context context,
                                const krb5_keyblock *key,
                                const krb5_authdata *ad_kdcissued,
                                krb5_principal *issuer,
                                krb5_authdata ***authdata);

/*
 * Windows PAC
 */
struct krb5_pac_data;
typedef struct krb5_pac_data *krb5_pac;

krb5_error_code KRB5_CALLCONV
krb5_pac_add_buffer(krb5_context context, krb5_pac pac, krb5_ui_4 type,
                    const krb5_data *data);

void KRB5_CALLCONV
krb5_pac_free(krb5_context context, krb5_pac pac);

krb5_error_code KRB5_CALLCONV
krb5_pac_get_buffer(krb5_context context, krb5_pac pac, krb5_ui_4 type,
                    krb5_data *data);

krb5_error_code KRB5_CALLCONV
krb5_pac_get_types(krb5_context context, krb5_pac pac, size_t *len,
                   krb5_ui_4 **types);

krb5_error_code KRB5_CALLCONV
krb5_pac_init(krb5_context context, krb5_pac *pac);

krb5_error_code KRB5_CALLCONV
krb5_pac_parse(krb5_context context, const void *ptr, size_t len,
               krb5_pac *pac);

krb5_error_code KRB5_CALLCONV
krb5_pac_verify(krb5_context context, const krb5_pac pac,
                krb5_timestamp authtime, krb5_const_principal principal,
                const krb5_keyblock *server, const krb5_keyblock *privsvr);

/**
 * @brief Allows the appplication to override the profile's allow_weak_crypto setting.
 *
 * Primarily for use by aklog.
 */
krb5_error_code KRB5_CALLCONV
krb5_allow_weak_crypto(krb5_context context, krb5_boolean enable);

/* This structure may be extended to contain more fields in the future. */
struct krb5_trace_info {
    const char *message;
};

typedef void
(KRB5_CALLCONV *krb5_trace_callback)(krb5_context context,
                                     const struct krb5_trace_info *info,
                                     void *cb_data);

/**
 * Specify a callback for trace events occurring in krb5 operations performed
 * within @a context.  @a fn will be invoked with @a context as the first
 * argument, @a cb_data as the last argument, and a pointer to a struct
 * krb5_trace_info as the second argument.  If the trace callback is reset via
 * this function or @a context is destroyed, @a fn will be invoked with a NULL
 * second argument to allow cleanup of @a cb_data.  Supply a NULL value for @a
 * fn to disable trace callbacks within @a context.
 *
 * @return Returns KRB5_TRACE_NOSUPP if tracing is not supported in the library (unless
 * @a fn is NULL).
 */
krb5_error_code KRB5_CALLCONV
krb5_set_trace_callback(krb5_context context, krb5_trace_callback fn,
                        void *cb_data);

/**
 * Open @a filename for appending (creating it, if necessary) and set up a
 * callback to write trace events to it.  Returns KRB5_TRACE_NOSUPP if tracing
 * is not supported in the library.
 */
krb5_error_code KRB5_CALLCONV
krb5_set_trace_filename(krb5_context context, const char *filename);

#if TARGET_OS_MAC
#    pragma pack(pop)
#endif

KRB5INT_END_DECLS

/* Don't use this!  We're going to phase it out.  It's just here to keep
   applications from breaking right away.  */
#define krb5_const const

#undef KRB5_ATTR_DEPRECATED

#endif /* KRB5_GENERAL__ */
